[
  {
    "name": "Process",
    "comment": "\n\n# Processes\n@docs Id, spawn, sleep, kill\n\n## Future Plans\n\nRight now, this library is pretty sparse. For example, there is no public API\nfor processes to communicate with each other. This is a really important\nability, but it is also something that is extraordinarily easy to get wrong!\n\nI think the trend will be towards an Erlang style of concurrency, where every\nprocess has an “event queue” that anyone can send messages to. I currently\nthink the API will be extended to be more like this:\n\n    type Id exit msg\n\n    spawn : Task exit a -> Task x (Id exit Never)\n\n    kill : Id exit msg -> Task x ()\n\n    send : Id exit msg -> msg -> Task x ()\n\nA process `Id` will have two type variables to make sure all communication is\nvalid. The `exit` type describes the messages that are produced if the process\nfails because of user code. So if processes are linked and trapping errors,\nthey will need to handle this. The `msg` type just describes what kind of\nmessages this process can be sent by strangers.\n\nWe shall see though! This is just a draft that does not cover nearly everything\nit needs to, so the long-term vision for concurrency in Elm will be rolling out\nslowly as I get more data and experience.\n\nI ask that people bullish on compiling to node.js keep this in mind. I think we\ncan do better than the hopelessly bad concurrency model of node.js, and I hope\nthe Elm community will be supportive of being more ambitious, even if it takes\nlonger. That’s kind of what Elm is all about.\n",
    "aliases": [
      {
        "name": "Id",
        "comment": " A light-weight process that runs concurrently. You can use `spawn` to\nget a bunch of different tasks running in different processes. The Elm runtime\nwill interleave their progress. So if a task is taking too long, we will pause\nit at an `andThen` and switch over to other stuff.\n\n**Note:** We make a distinction between *concurrency* which means interleaving\ndifferent sequences and *parallelism* which means running different\nsequences at the exact same time. For example, a\n[time-sharing system](https://en.wikipedia.org/wiki/Time-sharing) is definitely\nconcurrent, but not necessarily parallel. So even though JS runs within a\nsingle OS-level thread, Elm can still run things concurrently.\n",
        "args": [],
        "type": "Platform.ProcessId"
      }
    ],
    "types": [],
    "values": [
      {
        "name": "kill",
        "comment": " Sometimes you `spawn` a process, but later decide it would be a waste to\nhave it keep running and doing stuff. The `kill` function will force a process\nto bail on whatever task it is running. So if there is an HTTP request in\nflight, it will also abort the request.\n",
        "type": "Process.Id -> Task.Task x ()"
      },
      {
        "name": "sleep",
        "comment": " Block progress on the current process for a given amount of time. The\nJavaScript equivalent of this is [`setTimeout`][setTimeout] which lets you\ndelay work until later.\n\n[setTimeout]: https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setTimeout\n",
        "type": "Time.Time -> Task.Task x ()"
      },
      {
        "name": "spawn",
        "comment": " Run a task in its own light-weight process. In the following example,\n`task1` and `task2` will be interleaved. If `task1` makes a long HTTP request\nor is just taking a long time, we can hop over to `task2` and do some work\nthere.\n\n    spawn task1 `Task.andThen` \\_ -> spawn task2\n\n**Note:** This creates a relatively restricted kind of `Process` because it\ncannot receive any messages. More flexibility for user-defined processes will\ncome in a later release!\n",
        "type": "Task.Task x a -> Task.Task y Process.Id"
      }
    ],
    "generated-with-elm-version": "0.17.0"
  },
  {
    "name": "Random",
    "comment": " This library helps you generate pseudo-random values.\n\nThis library is all about building [`generators`](#Generator) for whatever\ntype of values you need. There are a bunch of primitive generators like\n[`bool`](#bool) and [`int`](#int) that you can build up into fancier\ngenerators with functions like [`list`](#list) and [`map`](#map).\n\nIt may be helpful to [read about JSON decoders][json] because they work very\nsimilarly.\n\n[json]: https://evancz.gitbooks.io/an-introduction-to-elm/content/interop/json.html\n\n> *Note:* This is an implementation of the Portable Combined Generator of\nL'Ecuyer for 32-bit computers. It is almost a direct translation from the\n[System.Random](http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html)\nmodule. It has a period of roughly 2.30584e18.\n\n# Generators\n@docs Generator\n\n# Primitive Generators\n@docs bool, int, float\n\n# Data Structure Generators\n@docs pair, list\n\n# Custom Generators\n@docs map, map2, map3, map4, map5, andThen\n\n# Generate Values\n@docs generate\n\n# Generate Values Manually\n@docs step, Seed, initialSeed\n\n# Constants\n@docs maxInt, minInt\n\n",
    "aliases": [],
    "types": [
      {
        "name": "Generator",
        "comment": " A `Generator` is like a recipe for generating certain random values. So a\n`Generator Int` describes how to generate integers and a `Generator String`\ndescribes how to generate strings.\n\nTo actually *run* a generator and produce the random values, you need to use\nfunctions like [`generate`](#generate) and [`initialSeed`](#initialSeed).\n",
        "args": [
          "a"
        ],
        "cases": []
      },
      {
        "name": "Seed",
        "comment": " A `Seed` is the source of randomness in this whole system. Whenever\nyou want to use a generator, you need to pair it with a seed.\n",
        "args": [],
        "cases": []
      }
    ],
    "values": [
      {
        "name": "andThen",
        "comment": " Chain random operations, threading through the seed. In the following\nexample, we will generate a random letter by putting together uppercase and\nlowercase letters.\n\n    letter : Generator Char\n    letter =\n      bool `andThen` \\b ->\n        if b then uppercaseLetter else lowercaseLetter\n\n    -- bool : Generator Bool\n    -- uppercaseLetter : Generator Char\n    -- lowercaseLetter : Generator Char\n",
        "type": "Random.Generator a -> (a -> Random.Generator b) -> Random.Generator b"
      },
      {
        "name": "bool",
        "comment": " Create a generator that produces boolean values. The following example\nsimulates a coin flip that may land heads or tails.\n\n    type Flip = Heads | Tails\n\n    coinFlip : Generator Flip\n    coinFlip =\n        map (\\b -> if b then Heads else Tails) bool\n",
        "type": "Random.Generator Bool"
      },
      {
        "name": "float",
        "comment": " Generate floats in a given range. The following example is a generator\nthat produces decimals between 0 and 1.\n\n    probability : Generator Float\n    probability =\n        float 0 1\n",
        "type": "Float -> Float -> Random.Generator Float"
      },
      {
        "name": "generate",
        "comment": " Create a command that will generate random values.\n\nRead more about how to use this in your programs in [The Elm Architecture\ntutorial][arch] which has a section specifically [about random values][rand].\n\n[arch]: https://evancz.gitbooks.io/an-introduction-to-elm/content/architecture/index.html\n[rand]: https://evancz.gitbooks.io/an-introduction-to-elm/content/architecture/effects/random.html\n",
        "type": "(a -> msg) -> Random.Generator a -> Platform.Cmd.Cmd msg"
      },
      {
        "name": "initialSeed",
        "comment": " Create a &ldquo;seed&rdquo; of randomness which makes it possible to\ngenerate random values. If you use the same seed many times, it will result\nin the same thing every time! A good way to get an unexpected seed is to use\nthe current time.\n",
        "type": "Int -> Random.Seed"
      },
      {
        "name": "int",
        "comment": " Generate 32-bit integers in a given range.\n\n    int 0 10   -- an integer between zero and ten\n    int -5 5   -- an integer between -5 and 5\n\n    int minInt maxInt  -- an integer in the widest range feasible\n\nThis function *can* produce values outside of the range [[`minInt`](#minInt),\n[`maxInt`](#maxInt)] but sufficient randomness is not guaranteed.\n",
        "type": "Int -> Int -> Random.Generator Int"
      },
      {
        "name": "list",
        "comment": " Create a list of random values.\n\n    floatList : Generator (List Float)\n    floatList =\n        list 10 (float 0 1)\n\n    intList : Generator (List Int)\n    intList =\n        list 5 (int 0 100)\n\n    intPairs : Generator (List (Int, Int))\n    intPairs =\n        list 10 <| pair (int 0 100) (int 0 100)\n",
        "type": "Int -> Random.Generator a -> Random.Generator (List a)"
      },
      {
        "name": "map",
        "comment": " Transform the values produced by a generator. The following examples show\nhow to generate booleans and letters based on a basic integer generator.\n\n    bool : Generator Bool\n    bool =\n      map ((==) 1) (int 0 1)\n\n    lowercaseLetter : Generator Char\n    lowercaseLetter =\n      map (\\n -> Char.fromCode (n + 97)) (int 0 25)\n\n    uppercaseLetter : Generator Char\n    uppercaseLetter =\n      map (\\n -> Char.fromCode (n + 65)) (int 0 25)\n\n",
        "type": "(a -> b) -> Random.Generator a -> Random.Generator b"
      },
      {
        "name": "map2",
        "comment": " Combine two generators.\n\nThis function is used to define things like [`pair`](#pair) where you want to\nput two generators together.\n\n    pair : Generator a -> Generator b -> Generator (a,b)\n    pair genA genB =\n      map2 (,) genA genB\n\n",
        "type": "(a -> b -> c) -> Random.Generator a -> Random.Generator b -> Random.Generator c"
      },
      {
        "name": "map3",
        "comment": " Combine three generators. This could be used to produce random colors.\n\n    import Color\n\n    rgb : Generator Color.Color\n    rgb =\n      map3 Color.rgb (int 0 255) (int 0 255) (int 0 255)\n\n    hsl : Generator Color.Color\n    hsl =\n      map3 Color.hsl (map degrees (int 0 360)) (float 0 1) (float 0 1)\n",
        "type": "(a -> b -> c -> d) -> Random.Generator a -> Random.Generator b -> Random.Generator c -> Random.Generator d"
      },
      {
        "name": "map4",
        "comment": " Combine four generators.\n",
        "type": "(a -> b -> c -> d -> e) -> Random.Generator a -> Random.Generator b -> Random.Generator c -> Random.Generator d -> Random.Generator e"
      },
      {
        "name": "map5",
        "comment": " Combine five generators.\n",
        "type": "(a -> b -> c -> d -> e -> f) -> Random.Generator a -> Random.Generator b -> Random.Generator c -> Random.Generator d -> Random.Generator e -> Random.Generator f"
      },
      {
        "name": "maxInt",
        "comment": " The maximum value for randomly generated 32-bit ints: 2147483647 ",
        "type": "Int"
      },
      {
        "name": "minInt",
        "comment": " The minimum value for randomly generated 32-bit ints: -2147483648 ",
        "type": "Int"
      },
      {
        "name": "pair",
        "comment": " Create a pair of random values. A common use of this might be to generate\na point in a certain 2D space. Imagine we have a collage that is 400 pixels\nwide and 200 pixels tall.\n\n    randomPoint : Generator (Int,Int)\n    randomPoint =\n        pair (int -200 200) (int -100 100)\n\n",
        "type": "Random.Generator a -> Random.Generator b -> Random.Generator ( a, b )"
      },
      {
        "name": "step",
        "comment": " Generate a random value as specified by a given `Generator`.\n\nIn the following example, we are trying to generate a number between 0 and 100\nwith the `int 0 100` generator. Each time we call `step` we need to provide a\nseed. This will produce a random number and a *new* seed to use if we want to\nrun other generators later.\n\nSo here it is done right, where we get a new seed from each `step` call and\nthread that through.\n\n    seed0 = initialSeed 31415\n\n    -- step (int 0 100) seed0 ==> (42, seed1)\n    -- step (int 0 100) seed1 ==> (31, seed2)\n    -- step (int 0 100) seed2 ==> (99, seed3)\n\nNotice that we use different seeds on each line. This is important! If you use\nthe same seed, you get the same results.\n\n    -- step (int 0 100) seed0 ==> (42, seed1)\n    -- step (int 0 100) seed0 ==> (42, seed1)\n    -- step (int 0 100) seed0 ==> (42, seed1)\n",
        "type": "Random.Generator a -> Random.Seed -> ( a, Random.Seed )"
      }
    ],
    "generated-with-elm-version": "0.17.0"
  },
  {
    "name": "Date",
    "comment": " Library for working with dates. Email the mailing list if you encounter\nissues with internationalization or locale formatting.\n\n# Dates\n@docs Date, now\n\n# Conversions\n@docs fromString, toTime, fromTime\n\n# Extractions\n@docs year, month, Month, day, dayOfWeek, Day, hour, minute, second, millisecond\n\n",
    "aliases": [],
    "types": [
      {
        "name": "Date",
        "comment": " Representation of a date.\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Day",
        "comment": " Represents the days of the week.\n",
        "args": [],
        "cases": [
          [
            "Mon",
            []
          ],
          [
            "Tue",
            []
          ],
          [
            "Wed",
            []
          ],
          [
            "Thu",
            []
          ],
          [
            "Fri",
            []
          ],
          [
            "Sat",
            []
          ],
          [
            "Sun",
            []
          ]
        ]
      },
      {
        "name": "Month",
        "comment": " Represents the month of the year.\n",
        "args": [],
        "cases": [
          [
            "Jan",
            []
          ],
          [
            "Feb",
            []
          ],
          [
            "Mar",
            []
          ],
          [
            "Apr",
            []
          ],
          [
            "May",
            []
          ],
          [
            "Jun",
            []
          ],
          [
            "Jul",
            []
          ],
          [
            "Aug",
            []
          ],
          [
            "Sep",
            []
          ],
          [
            "Oct",
            []
          ],
          [
            "Nov",
            []
          ],
          [
            "Dec",
            []
          ]
        ]
      }
    ],
    "values": [
      {
        "name": "day",
        "comment": " Extract the day of a given date. Given the date 23 June 1990 at 11:45AM\nthis returns the integer `23`.\n",
        "type": "Date.Date -> Int"
      },
      {
        "name": "dayOfWeek",
        "comment": " Extract the day of the week for a given date. Given the date 23 June\n1990 at 11:45AM this returns the day `Sat` as defined below.\n",
        "type": "Date.Date -> Date.Day"
      },
      {
        "name": "fromString",
        "comment": " Attempt to read a date from a string.\n",
        "type": "String -> Result.Result String Date.Date"
      },
      {
        "name": "fromTime",
        "comment": " Convert a time in milliseconds into a `Date`.\n\nA time is the number of milliseconds since\n[the Unix epoch](http://en.wikipedia.org/wiki/Unix_time).\n",
        "type": "Time.Time -> Date.Date"
      },
      {
        "name": "hour",
        "comment": " Extract the hour of a given date. Given the date 23 June 1990 at 11:45AM\nthis returns the integer `11`.\n",
        "type": "Date.Date -> Int"
      },
      {
        "name": "millisecond",
        "comment": " Extract the millisecond of a given date. Given the date 23 June 1990 at 11:45:30.123AM\nthis returns the integer `123`.\n",
        "type": "Date.Date -> Int"
      },
      {
        "name": "minute",
        "comment": " Extract the minute of a given date. Given the date 23 June 1990 at 11:45AM\nthis returns the integer `45`.\n",
        "type": "Date.Date -> Int"
      },
      {
        "name": "month",
        "comment": " Extract the month of a given date. Given the date 23 June 1990 at 11:45AM\nthis returns the month `Jun` as defined below.\n",
        "type": "Date.Date -> Date.Month"
      },
      {
        "name": "now",
        "comment": " Get the `Date` at the moment when this task is run.\n",
        "type": "Task.Task x Date.Date"
      },
      {
        "name": "second",
        "comment": " Extract the second of a given date. Given the date 23 June 1990 at 11:45AM\nthis returns the integer `0`.\n",
        "type": "Date.Date -> Int"
      },
      {
        "name": "toTime",
        "comment": " Convert a `Date` to a time in milliseconds.\n\nA time is the number of milliseconds since\n[the Unix epoch](http://en.wikipedia.org/wiki/Unix_time).\n",
        "type": "Date.Date -> Time.Time"
      },
      {
        "name": "year",
        "comment": " Extract the year of a given date. Given the date 23 June 1990 at 11:45AM\nthis returns the integer `1990`.\n",
        "type": "Date.Date -> Int"
      }
    ],
    "generated-with-elm-version": "0.17.0"
  },
  {
    "name": "Time",
    "comment": " Library for working with time.\n\n# Time\n@docs Time, now, every\n\n# Units\n@docs millisecond, second, minute, hour,\n  inMilliseconds, inSeconds, inMinutes, inHours\n\n",
    "aliases": [
      {
        "name": "Time",
        "comment": " Type alias to make it clearer when you are working with time values.\nUsing the `Time` helpers like `second` and `inSeconds` instead of raw numbers\nis very highly recommended.\n",
        "args": [],
        "type": "Float"
      }
    ],
    "types": [],
    "values": [
      {
        "name": "every",
        "comment": " Subscribe to the current time. First you provide an interval describing how\nfrequently you want updates. Second, you give a tagger that turns a time into a\nmessage for your `update` function. So if you want to hear about the current\ntime every second, you would say something like this:\n\n    type Msg = Tick Time | ...\n\n    subscriptions model =\n      every second Tick\n\nCheck out the [Elm Architecture Tutorial][arch] for more info on how\nsubscriptions work.\n\n[arch]: https://github.com/evancz/elm-architecture-tutorial/\n\n**Note:** this function is not for animation! You need to use something based\non `requestAnimationFrame` to get smooth animations. This is based on\n`setInterval` which is better for recurring tasks like “check on something\nevery 30 seconds”.\n",
        "type": "Time.Time -> (Time.Time -> msg) -> Platform.Sub.Sub msg"
      },
      {
        "name": "hour",
        "comment": "",
        "type": "Time.Time"
      },
      {
        "name": "inHours",
        "comment": "",
        "type": "Time.Time -> Float"
      },
      {
        "name": "inMilliseconds",
        "comment": "",
        "type": "Time.Time -> Float"
      },
      {
        "name": "inMinutes",
        "comment": "",
        "type": "Time.Time -> Float"
      },
      {
        "name": "inSeconds",
        "comment": "",
        "type": "Time.Time -> Float"
      },
      {
        "name": "millisecond",
        "comment": " Units of time, making it easier to specify things like a half-second\n`(500 * millisecond)` without remembering Elm&rsquo;s underlying units of time.\n",
        "type": "Time.Time"
      },
      {
        "name": "minute",
        "comment": "",
        "type": "Time.Time"
      },
      {
        "name": "now",
        "comment": " Get the `Time` at the moment when this task is run.\n",
        "type": "Task.Task x Time.Time"
      },
      {
        "name": "second",
        "comment": "",
        "type": "Time.Time"
      }
    ],
    "generated-with-elm-version": "0.17.0"
  },
  {
    "name": "Json.Decode",
    "comment": " A way to turn Json values into Elm values. A `Decoder a` represents a\ndecoding operation that will either produce a value of type `a`, or fail.\n\n# Decoders\n@docs Decoder, Value\n\n# Run a Decoder\n@docs decodeString, decodeValue\n\n# Primitives\n@docs string, int, float, bool, null\n\n# Arrays\n@docs list, array,\n  tuple1, tuple2, tuple3, tuple4, tuple5, tuple6, tuple7, tuple8\n\n# Objects\n@docs (:=), at,\n  object1, object2, object3, object4, object5, object6, object7, object8,\n  keyValuePairs, dict\n\n# Oddly Shaped Values\n@docs maybe, oneOf, map, fail, succeed, andThen\n\n# \"Creative\" Values\n@docs value, customDecoder\n",
    "aliases": [
      {
        "name": "Value",
        "comment": " Represents a JavaScript value.\n",
        "args": [],
        "type": "Json.Encode.Value"
      }
    ],
    "types": [
      {
        "name": "Decoder",
        "comment": " Represents a way of decoding JSON values. If you have a `(Decoder (List String))`\nit will attempt to take some JSON value and turn it into a list of strings.\nThese decoders are easy to put together so you can create more and more complex\ndecoders.\n",
        "args": [
          "a"
        ],
        "cases": []
      }
    ],
    "values": [
      {
        "name": ":=",
        "comment": " Applies the decoder to the field with the given name.\nFails if the JSON object has no such field.\n\n    nameAndAge : Decoder (String,Int)\n    nameAndAge =\n        object2 (,)\n          (\"name\" := string)\n          (\"age\" := int)\n\n    optionalProfession : Decoder (Maybe String)\n    optionalProfession =\n        maybe (\"profession\" := string)\n",
        "type": "String -> Json.Decode.Decoder a -> Json.Decode.Decoder a"
      },
      {
        "name": "andThen",
        "comment": " Helpful when a field tells you about the overall structure of the JSON\nyou are dealing with. For example, imagine we are getting JSON representing\ndifferent shapes. Data like this:\n\n    { \"tag\": \"rectangle\", \"width\": 2, \"height\": 3 }\n    { \"tag\": \"circle\", \"radius\": 2 }\n\nThe following `shape` decoder looks at the `tag` to know what other fields to\nexpect **and then** it extracts the relevant information.\n\n    type Shape\n      = Rectangle Float Float\n      | Circle Float\n\n    shape : Decoder Shape\n    shape =\n      (\"tag\" := string) `andThen` shapeInfo\n\n    shapeInfo : String -> Decoder Shape\n    shapeInfo tag =\n      case tag of\n        \"rectangle\" ->\n          object2 Rectangle (\"width\" := float) (\"height\" := float)\n\n        \"circle\" ->\n          object1 Circle (\"radius\" := float)\n\n        _ ->\n          fail (tag ++ \" is not a recognized tag for shapes\")\n",
        "type": "Json.Decode.Decoder a -> (a -> Json.Decode.Decoder b) -> Json.Decode.Decoder b"
      },
      {
        "name": "array",
        "comment": " Extract an Array from a JS array.\n\n    -- [1,2,3,4]\n\n    numbers : Decoder (Array Int)\n    numbers =\n        array int\n",
        "type": "Json.Decode.Decoder a -> Json.Decode.Decoder (Array.Array a)"
      },
      {
        "name": "at",
        "comment": " Access a nested field, making it easy to dive into big structures. This is\nreally a helper function so you do not need to write `(:=)` so many times.\n\n    -- object.target.value = 'hello'\n    value : Decoder String\n    value =\n        at [\"target\", \"value\"] string\n\nIt is defined as\n\n    at fields decoder =\n        List.foldr (:=) decoder fields\n",
        "type": "List String -> Json.Decode.Decoder a -> Json.Decode.Decoder a"
      },
      {
        "name": "bool",
        "comment": " Extract a boolean.\n\n    -- { ... \"checked\": true ... }\n\n    checked : Decoder Bool\n    checked =\n        \"checked\" := bool\n",
        "type": "Json.Decode.Decoder Bool"
      },
      {
        "name": "customDecoder",
        "comment": " Create a custom decoder that may do some fancy computation. See the `value`\ndocumentation for an example usage.\n",
        "type": "Json.Decode.Decoder a -> (a -> Result.Result String b) -> Json.Decode.Decoder b"
      },
      {
        "name": "decodeString",
        "comment": " Using a certain decoder, attempt to parse a JSON string. If the decoder\nfails, you will get a string message telling you why.\n\n    decodeString (tuple2 (,) float float) \"[3,4]\"                  -- Ok (3,4)\n    decodeString (tuple2 (,) float float) \"{ \\\"x\\\": 3, \\\"y\\\": 4 }\" -- Err \"\"\n",
        "type": "Json.Decode.Decoder a -> String -> Result.Result String a"
      },
      {
        "name": "decodeValue",
        "comment": " Using a certain decoder, attempt to parse a raw `Json.Value`. You can pass\na `Json.Value` into Elm through a port, so this can let you handle data with\nextra weird shapes or stuff that currently is not allowed through ports\nautomatically.\n\n    port jsonValues : Signal Json.Value\n\n    shapes : Signal (Result String Shape)\n    shapes =\n      Signal.map (decodeValue shape) jsonValues\n\n    type Shape\n        = Rectangle Float Float\n        | Circle Float\n\n    shape : Decoder Shape  -- see definition in `andThen` docs\n",
        "type": "Json.Decode.Decoder a -> Json.Decode.Value -> Result.Result String a"
      },
      {
        "name": "dict",
        "comment": " Turn any object into a dictionary of key-value pairs, including inherited enumerable properties. Fails if _any_ value can't be\ndecoded with the given decoder.\n\n    -- { \"mercury\": 0.33, \"venus\": 4.87, \"earth\": 5.97, ... }\n    planetMasses : Decoder (Dict String Float)\n    planetMasses =\n        dict float\n",
        "type": "Json.Decode.Decoder a -> Json.Decode.Decoder (Dict.Dict String a)"
      },
      {
        "name": "fail",
        "comment": " A decoder that always fails. Useful when paired with `andThen` or `oneOf`\nto improve error messages when things go wrong. For example, the following\ndecoder is able to provide a much more specific error message when `fail` is\nthe last option.\n\n    point : Decoder (Float,Float)\n    point =\n        oneOf\n        [ tuple2 (,) float float\n        , object2 (,) (\"x\" := float) (\"y\" := float)\n        , fail \"expecting some kind of point\"\n        ]\n",
        "type": "String -> Json.Decode.Decoder a"
      },
      {
        "name": "float",
        "comment": " Extract a float.\n\n    -- [ 6.022, 3.1415, 1.618 ]\n\n    numbers : Decoder (List Float)\n    numbers =\n        list float\n",
        "type": "Json.Decode.Decoder Float"
      },
      {
        "name": "int",
        "comment": " Extract an integer.\n\n    -- { ... \"age\": 42 ... }\n\n    age : Decoder Int\n    age =\n        \"age\" := int\n",
        "type": "Json.Decode.Decoder Int"
      },
      {
        "name": "keyValuePairs",
        "comment": " Turn any object into a list of key-value pairs, including inherited enumerable properties. Fails if _any_ value can't be\ndecoded with the given decoder.\n\n    -- { \"tom\": 89, \"sue\": 92, \"bill\": 97, ... }\n    grades : Decoder (List (String, Int))\n    grades =\n        keyValuePairs int\n",
        "type": "Json.Decode.Decoder a -> Json.Decode.Decoder (List ( String, a ))"
      },
      {
        "name": "list",
        "comment": " Extract a List from a JS array.\n\n    -- [1,2,3,4]\n\n    numbers : Decoder (List Int)\n    numbers =\n        list int\n",
        "type": "Json.Decode.Decoder a -> Json.Decode.Decoder (List a)"
      },
      {
        "name": "map",
        "comment": " Transform the value returned by a decoder. Most useful when paired with\nthe `oneOf` function.\n\n    nullOr : Decoder a -> Decoder (Maybe a)\n    nullOr decoder =\n        oneOf\n          [ null Nothing\n          , map Just decoder\n          ]\n\n    type UserID = OldID Int | NewID String\n\n    -- 1234 or \"1234abc\"\n    userID : Decoder UserID\n    userID =\n        oneOf\n          [ map OldID int\n          , map NewID string\n          ]\n",
        "type": "(a -> b) -> Json.Decode.Decoder a -> Json.Decode.Decoder b"
      },
      {
        "name": "maybe",
        "comment": " Extract a Maybe value, wrapping successes with `Just` and turning any\nfailure in `Nothing`. If you are expecting that a field can sometimes be `null`,\nit's better to check for it [explicitly](#null), as this function will swallow\nerrors from ill-formed JSON.\n\nThe following code decodes JSON objects that may not have a profession field.\n\n    -- profession: Just \"plumber\"\n    -- { name: \"Tom\", age: 31, profession: \"plumber\" }\n    -- profession: Nothing\n    -- { name: \"Sue\", age: 42 }\n    -- { name: \"Amy\", age: 27, profession: null }\n    -- { name: \"Joe\", age: 36, profession: [\"something\", \"unexpected\"] }\n\n    type alias Person =\n        { name : String\n        , age : Int\n        , profession : Maybe String\n        }\n\n    person : Decoder Person\n    person =\n        object3 Person\n          (\"name\" := string)\n          (\"age\" := int)\n          (maybe (\"profession\" := string))\n",
        "type": "Json.Decode.Decoder a -> Json.Decode.Decoder (Maybe.Maybe a)"
      },
      {
        "name": "null",
        "comment": " Decode null as the value given, and fail otherwise. Primarily useful for\ncreating *other* decoders.\n\n    numbers : Decoder [Int]\n    numbers =\n        list (oneOf [ int, null 0 ])\n\nThis decoder treats `null` as `Nothing`, and otherwise tries to produce a\n`Just`.\n\n    nullOr : Decoder a -> Decoder (Maybe a)\n    nullOr decoder =\n        oneOf\n        [ null Nothing\n        , map Just decoder\n        ]\n",
        "type": "a -> Json.Decode.Decoder a"
      },
      {
        "name": "object1",
        "comment": " Apply a function to a decoder. You can use this function as `map` if you\nmust (which can be done with any `objectN` function actually).\n\n    object1 sqrt (\"x\" := float)\n",
        "type": "(a -> value) -> Json.Decode.Decoder a -> Json.Decode.Decoder value"
      },
      {
        "name": "object2",
        "comment": " Use two different decoders on a JS value. This is nice for extracting\nmultiple fields from an object.\n\n    point : Decoder (Float,Float)\n    point =\n        object2 (,)\n          (\"x\" := float)\n          (\"y\" := float)\n",
        "type": "(a -> b -> value) -> Json.Decode.Decoder a -> Json.Decode.Decoder b -> Json.Decode.Decoder value"
      },
      {
        "name": "object3",
        "comment": " Use three different decoders on a JS value. This is nice for extracting\nmultiple fields from an object.\n\n    type alias Job = { name : String, id : Int, completed : Bool }\n\n    job : Decoder Job\n    job =\n        object3 Job\n          (\"name\" := string)\n          (\"id\" := int)\n          (\"completed\" := bool)\n",
        "type": "(a -> b -> c -> value) -> Json.Decode.Decoder a -> Json.Decode.Decoder b -> Json.Decode.Decoder c -> Json.Decode.Decoder value"
      },
      {
        "name": "object4",
        "comment": "",
        "type": "(a -> b -> c -> d -> value) -> Json.Decode.Decoder a -> Json.Decode.Decoder b -> Json.Decode.Decoder c -> Json.Decode.Decoder d -> Json.Decode.Decoder value"
      },
      {
        "name": "object5",
        "comment": "",
        "type": "(a -> b -> c -> d -> e -> value) -> Json.Decode.Decoder a -> Json.Decode.Decoder b -> Json.Decode.Decoder c -> Json.Decode.Decoder d -> Json.Decode.Decoder e -> Json.Decode.Decoder value"
      },
      {
        "name": "object6",
        "comment": "",
        "type": "(a -> b -> c -> d -> e -> f -> value) -> Json.Decode.Decoder a -> Json.Decode.Decoder b -> Json.Decode.Decoder c -> Json.Decode.Decoder d -> Json.Decode.Decoder e -> Json.Decode.Decoder f -> Json.Decode.Decoder value"
      },
      {
        "name": "object7",
        "comment": "",
        "type": "(a -> b -> c -> d -> e -> f -> g -> value) -> Json.Decode.Decoder a -> Json.Decode.Decoder b -> Json.Decode.Decoder c -> Json.Decode.Decoder d -> Json.Decode.Decoder e -> Json.Decode.Decoder f -> Json.Decode.Decoder g -> Json.Decode.Decoder value"
      },
      {
        "name": "object8",
        "comment": "",
        "type": "(a -> b -> c -> d -> e -> f -> g -> h -> value) -> Json.Decode.Decoder a -> Json.Decode.Decoder b -> Json.Decode.Decoder c -> Json.Decode.Decoder d -> Json.Decode.Decoder e -> Json.Decode.Decoder f -> Json.Decode.Decoder g -> Json.Decode.Decoder h -> Json.Decode.Decoder value"
      },
      {
        "name": "oneOf",
        "comment": " Try out multiple different decoders. This is helpful when you are dealing\nwith something with a very strange shape and when `andThen` does not help\nnarrow things down so you can be more targeted.\n\n    -- [ [3,4], { \"x\":0, \"y\":0 }, [5,12] ]\n\n    points : Decoder (List (Float,Float))\n    points =\n        list point\n\n    point : Decoder (Float,Float)\n    point =\n        oneOf\n        [ tuple2 (,) float float\n        , object2 (,) (\"x\" := float) (\"y\" := float)\n        ]\n",
        "type": "List (Json.Decode.Decoder a) -> Json.Decode.Decoder a"
      },
      {
        "name": "string",
        "comment": " Extract a string.\n\n    -- [\"John\",\"Doe\"]\n\n    name : Decoder (String, String)\n    name =\n        tuple2 (,) string string\n",
        "type": "Json.Decode.Decoder String"
      },
      {
        "name": "succeed",
        "comment": " A decoder that always succeeds. Useful when paired with `andThen` or\n`oneOf` but everything is supposed to work out at the end. For example,\nmaybe you have an optional field that can have a default value when it is\nmissing.\n\n    -- { x:3, y:4 } or { x:3, y:4, z:5 }\n\n    point3D : Decoder (Float,Float,Float)\n    point3D =\n        object3 (,,)\n          (\"x\" := float)\n          (\"y\" := float)\n          (oneOf [ \"z\" := float, succeed 0 ])\n",
        "type": "a -> Json.Decode.Decoder a"
      },
      {
        "name": "tuple1",
        "comment": " Handle an array with exactly one element.\n\n    extractString : Decoder String\n    extractString =\n        tuple1 identity string\n\n    authorship : Decoder String\n    authorship =\n        oneOf\n          [ tuple1 (\\author -> \"Author: \" ++ author) string\n          , list string |> map (\\authors -> \"Co-authors: \" ++ String.join \", \" authors)\n          ]\n",
        "type": "(a -> value) -> Json.Decode.Decoder a -> Json.Decode.Decoder value"
      },
      {
        "name": "tuple2",
        "comment": " Handle an array with exactly two elements. Useful for points and simple\npairs.\n\n    -- [3,4] or [0,0]\n    point : Decoder (Float,Float)\n    point =\n        tuple2 (,) float float\n\n    -- [\"John\",\"Doe\"] or [\"Hermann\",\"Hesse\"]\n    name : Decoder Name\n    name =\n        tuple2 Name string string\n\n    type alias Name = { first : String, last : String }\n",
        "type": "(a -> b -> value) -> Json.Decode.Decoder a -> Json.Decode.Decoder b -> Json.Decode.Decoder value"
      },
      {
        "name": "tuple3",
        "comment": " Handle an array with exactly three elements.\n\n    -- [3,4,5] or [0,0,0]\n    point3D : Decoder (Float,Float,Float)\n    point3D =\n        tuple3 (,,) float float float\n\n",
        "type": "(a -> b -> c -> value) -> Json.Decode.Decoder a -> Json.Decode.Decoder b -> Json.Decode.Decoder c -> Json.Decode.Decoder value"
      },
      {
        "name": "tuple4",
        "comment": "",
        "type": "(a -> b -> c -> d -> value) -> Json.Decode.Decoder a -> Json.Decode.Decoder b -> Json.Decode.Decoder c -> Json.Decode.Decoder d -> Json.Decode.Decoder value"
      },
      {
        "name": "tuple5",
        "comment": "",
        "type": "(a -> b -> c -> d -> e -> value) -> Json.Decode.Decoder a -> Json.Decode.Decoder b -> Json.Decode.Decoder c -> Json.Decode.Decoder d -> Json.Decode.Decoder e -> Json.Decode.Decoder value"
      },
      {
        "name": "tuple6",
        "comment": "",
        "type": "(a -> b -> c -> d -> e -> f -> value) -> Json.Decode.Decoder a -> Json.Decode.Decoder b -> Json.Decode.Decoder c -> Json.Decode.Decoder d -> Json.Decode.Decoder e -> Json.Decode.Decoder f -> Json.Decode.Decoder value"
      },
      {
        "name": "tuple7",
        "comment": "",
        "type": "(a -> b -> c -> d -> e -> f -> g -> value) -> Json.Decode.Decoder a -> Json.Decode.Decoder b -> Json.Decode.Decoder c -> Json.Decode.Decoder d -> Json.Decode.Decoder e -> Json.Decode.Decoder f -> Json.Decode.Decoder g -> Json.Decode.Decoder value"
      },
      {
        "name": "tuple8",
        "comment": "",
        "type": "(a -> b -> c -> d -> e -> f -> g -> h -> value) -> Json.Decode.Decoder a -> Json.Decode.Decoder b -> Json.Decode.Decoder c -> Json.Decode.Decoder d -> Json.Decode.Decoder e -> Json.Decode.Decoder f -> Json.Decode.Decoder g -> Json.Decode.Decoder h -> Json.Decode.Decoder value"
      },
      {
        "name": "value",
        "comment": " Bring in an arbitrary JSON value. Useful if you need to work with crazily\nformatted data. For example, this lets you create a parser for \"variadic\" lists\nwhere the first few types are different, followed by 0 or more of the same\ntype.\n\n    variadic2 : (a -> b -> List c -> value) -> Decoder a -> Decoder b -> Decoder c -> Decoder value\n    variadic2 f a b c =\n        let\n            combineResults = List.foldr (Result.map2 (::)) (Ok [])\n        in\n            customDecoder (list value) (\\jsonList ->\n                case jsonList of\n                  one :: two :: rest ->\n                      Result.map3 f\n                        (decodeValue a one)\n                        (decodeValue b two)\n                        (combineResults (List.map (decodeValue c) rest))\n\n                  _ -> Result.Err \"expecting at least two elements in the array\")\n",
        "type": "Json.Decode.Decoder Json.Decode.Value"
      }
    ],
    "generated-with-elm-version": "0.17.0"
  },
  {
    "name": "Set",
    "comment": " A set of unique values. The values can be any comparable type. This\nincludes `Int`, `Float`, `Time`, `Char`, `String`, and tuples or lists\nof comparable types.\n\nInsert, remove, and query operations all take *O(log n)* time. Set equality with\n`(==)` is unreliable and should not be used.\n\n# Sets\n@docs Set\n\n# Build\n@docs empty, singleton, insert, remove\n\n# Query\n@docs isEmpty, member, size\n\n# Combine\n@docs union, intersect, diff\n\n# Lists\n@docs toList, fromList\n\n# Transform\n@docs map, foldl, foldr, filter, partition\n\n",
    "aliases": [],
    "types": [
      {
        "name": "Set",
        "comment": " Represents a set of unique values. So `(Set Int)` is a set of integers and\n`(Set String)` is a set of strings.\n",
        "args": [
          "t"
        ],
        "cases": []
      }
    ],
    "values": [
      {
        "name": "diff",
        "comment": " Get the difference between the first set and the second. Keeps values\nthat do not appear in the second set.\n",
        "type": "Set.Set comparable -> Set.Set comparable -> Set.Set comparable"
      },
      {
        "name": "empty",
        "comment": " Create an empty set.\n",
        "type": "Set.Set a"
      },
      {
        "name": "filter",
        "comment": " Create a new set consisting only of elements which satisfy a predicate.\n",
        "type": "(comparable -> Bool) -> Set.Set comparable -> Set.Set comparable"
      },
      {
        "name": "foldl",
        "comment": " Fold over the values in a set, in order from lowest to highest.\n",
        "type": "(comparable -> b -> b) -> b -> Set.Set comparable -> b"
      },
      {
        "name": "foldr",
        "comment": " Fold over the values in a set, in order from highest to lowest.\n",
        "type": "(comparable -> b -> b) -> b -> Set.Set comparable -> b"
      },
      {
        "name": "fromList",
        "comment": " Convert a list into a set, removing any duplicates.\n",
        "type": "List comparable -> Set.Set comparable"
      },
      {
        "name": "insert",
        "comment": " Insert a value into a set.\n",
        "type": "comparable -> Set.Set comparable -> Set.Set comparable"
      },
      {
        "name": "intersect",
        "comment": " Get the intersection of two sets. Keeps values that appear in both sets.\n",
        "type": "Set.Set comparable -> Set.Set comparable -> Set.Set comparable"
      },
      {
        "name": "isEmpty",
        "comment": " Determine if a set is empty.\n",
        "type": "Set.Set a -> Bool"
      },
      {
        "name": "map",
        "comment": " Map a function onto a set, creating a new set with no duplicates.\n",
        "type": "(comparable -> comparable') -> Set.Set comparable -> Set.Set comparable'"
      },
      {
        "name": "member",
        "comment": " Determine if a value is in a set.\n",
        "type": "comparable -> Set.Set comparable -> Bool"
      },
      {
        "name": "partition",
        "comment": " Create two new sets; the first consisting of elements which satisfy a\npredicate, the second consisting of elements which do not.\n",
        "type": "(comparable -> Bool) -> Set.Set comparable -> ( Set.Set comparable, Set.Set comparable )"
      },
      {
        "name": "remove",
        "comment": " Remove a value from a set. If the value is not found, no changes are made.\n",
        "type": "comparable -> Set.Set comparable -> Set.Set comparable"
      },
      {
        "name": "singleton",
        "comment": " Create a set with one value.\n",
        "type": "comparable -> Set.Set comparable"
      },
      {
        "name": "size",
        "comment": " Determine the number of elements in a set.\n",
        "type": "Set.Set a -> Int"
      },
      {
        "name": "toList",
        "comment": " Convert a set into a list, sorted from lowest to highest.\n",
        "type": "Set.Set comparable -> List comparable"
      },
      {
        "name": "union",
        "comment": " Get the union of two sets. Keep all values.\n",
        "type": "Set.Set comparable -> Set.Set comparable -> Set.Set comparable"
      }
    ],
    "generated-with-elm-version": "0.17.0"
  },
  {
    "name": "Dict",
    "comment": " A dictionary mapping unique keys to values. The keys can be any comparable\ntype. This includes `Int`, `Float`, `Time`, `Char`, `String`, and tuples or\nlists of comparable types.\n\nInsert, remove, and query operations all take *O(log n)* time. Dictionary\nequality with `(==)` is unreliable and should not be used.\n\n# Dictionaries\n@docs Dict\n\n# Build\n@docs empty, singleton, insert, update, remove\n\n# Query\n@docs isEmpty, member, get, size\n\n# Lists\n@docs keys, values, toList, fromList\n\n# Transform\n@docs map, foldl, foldr, filter, partition\n\n# Combine\n@docs union, intersect, diff, merge\n\n",
    "aliases": [],
    "types": [
      {
        "name": "Dict",
        "comment": " A dictionary of keys and values. So a `(Dict String User)` is a dictionary\nthat lets you look up a `String` (such as user names) and find the associated\n`User`.\n",
        "args": [
          "k",
          "v"
        ],
        "cases": []
      }
    ],
    "values": [
      {
        "name": "diff",
        "comment": " Keep a key-value pair when its key does not appear in the second dictionary.\n",
        "type": "Dict.Dict comparable v -> Dict.Dict comparable v -> Dict.Dict comparable v"
      },
      {
        "name": "empty",
        "comment": " Create an empty dictionary. ",
        "type": "Dict.Dict k v"
      },
      {
        "name": "filter",
        "comment": " Keep a key-value pair when it satisfies a predicate. ",
        "type": "(comparable -> v -> Bool) -> Dict.Dict comparable v -> Dict.Dict comparable v"
      },
      {
        "name": "foldl",
        "comment": " Fold over the key-value pairs in a dictionary, in order from lowest\nkey to highest key.\n",
        "type": "(comparable -> v -> b -> b) -> b -> Dict.Dict comparable v -> b"
      },
      {
        "name": "foldr",
        "comment": " Fold over the key-value pairs in a dictionary, in order from highest\nkey to lowest key.\n",
        "type": "(comparable -> v -> b -> b) -> b -> Dict.Dict comparable v -> b"
      },
      {
        "name": "fromList",
        "comment": " Convert an association list into a dictionary. ",
        "type": "List ( comparable, v ) -> Dict.Dict comparable v"
      },
      {
        "name": "get",
        "comment": " Get the value associated with a key. If the key is not found, return\n`Nothing`. This is useful when you are not sure if a key will be in the\ndictionary.\n\n    animals = fromList [ (\"Tom\", Cat), (\"Jerry\", Mouse) ]\n\n    get \"Tom\"   animals == Just Cat\n    get \"Jerry\" animals == Just Mouse\n    get \"Spike\" animals == Nothing\n\n",
        "type": "comparable -> Dict.Dict comparable v -> Maybe.Maybe v"
      },
      {
        "name": "insert",
        "comment": " Insert a key-value pair into a dictionary. Replaces value when there is\na collision. ",
        "type": "comparable -> v -> Dict.Dict comparable v -> Dict.Dict comparable v"
      },
      {
        "name": "intersect",
        "comment": " Keep a key-value pair when its key appears in the second dictionary.\nPreference is given to values in the first dictionary.\n",
        "type": "Dict.Dict comparable v -> Dict.Dict comparable v -> Dict.Dict comparable v"
      },
      {
        "name": "isEmpty",
        "comment": " Determine if a dictionary is empty.\n\n    isEmpty empty == True\n",
        "type": "Dict.Dict k v -> Bool"
      },
      {
        "name": "keys",
        "comment": " Get all of the keys in a dictionary, sorted from lowest to highest.\n\n    keys (fromList [(0,\"Alice\"),(1,\"Bob\")]) == [0,1]\n",
        "type": "Dict.Dict comparable v -> List comparable"
      },
      {
        "name": "map",
        "comment": " Apply a function to all values in a dictionary.\n",
        "type": "(comparable -> a -> b) -> Dict.Dict comparable a -> Dict.Dict comparable b"
      },
      {
        "name": "member",
        "comment": " Determine if a key is in a dictionary. ",
        "type": "comparable -> Dict.Dict comparable v -> Bool"
      },
      {
        "name": "merge",
        "comment": " The most general way of combining two dictionaries. You provide three\naccumulators for when a given key appears:\n\n  1. Only in the left dictionary.\n  2. In both dictionaries.\n  3. Only in the right dictionary.\n\nYou then traverse all the keys from lowest to highest, building up whatever\nyou want.\n",
        "type": "(comparable -> a -> result -> result) -> (comparable -> a -> b -> result -> result) -> (comparable -> b -> result -> result) -> Dict.Dict comparable a -> Dict.Dict comparable b -> result -> result"
      },
      {
        "name": "partition",
        "comment": " Partition a dictionary according to a predicate. The first dictionary\ncontains all key-value pairs which satisfy the predicate, and the second\ncontains the rest.\n",
        "type": "(comparable -> v -> Bool) -> Dict.Dict comparable v -> ( Dict.Dict comparable v, Dict.Dict comparable v )"
      },
      {
        "name": "remove",
        "comment": " Remove a key-value pair from a dictionary. If the key is not found,\nno changes are made. ",
        "type": "comparable -> Dict.Dict comparable v -> Dict.Dict comparable v"
      },
      {
        "name": "singleton",
        "comment": " Create a dictionary with one key-value pair. ",
        "type": "comparable -> v -> Dict.Dict comparable v"
      },
      {
        "name": "size",
        "comment": " Determine the number of key-value pairs in the dictionary. ",
        "type": "Dict.Dict k v -> Int"
      },
      {
        "name": "toList",
        "comment": " Convert a dictionary into an association list of key-value pairs, sorted by keys. ",
        "type": "Dict.Dict comparable v -> List ( comparable, v )"
      },
      {
        "name": "union",
        "comment": " Combine two dictionaries. If there is a collision, preference is given\nto the first dictionary.\n",
        "type": "Dict.Dict comparable v -> Dict.Dict comparable v -> Dict.Dict comparable v"
      },
      {
        "name": "update",
        "comment": " Update the value of a dictionary for a specific key with a given function. ",
        "type": "comparable -> (Maybe.Maybe v -> Maybe.Maybe v) -> Dict.Dict comparable v -> Dict.Dict comparable v"
      },
      {
        "name": "values",
        "comment": " Get all of the values in a dictionary, in the order of their keys.\n\n    values (fromList [(0,\"Alice\"),(1,\"Bob\")]) == [\"Alice\", \"Bob\"]\n",
        "type": "Dict.Dict comparable v -> List v"
      }
    ],
    "generated-with-elm-version": "0.17.0"
  },
  {
    "name": "Json.Encode",
    "comment": " Library for turning Elm values into Json values.\n\n# Encoding\n@docs encode, Value\n\n# Primitives\n@docs string, int, float, bool, null\n\n# Arrays\n@docs list, array\n\n# Objects\n@docs object\n",
    "aliases": [],
    "types": [
      {
        "name": "Value",
        "comment": " Represents a JavaScript value.\n",
        "args": [],
        "cases": []
      }
    ],
    "values": [
      {
        "name": "array",
        "comment": "",
        "type": "Array.Array Json.Encode.Value -> Json.Encode.Value"
      },
      {
        "name": "bool",
        "comment": "",
        "type": "Bool -> Json.Encode.Value"
      },
      {
        "name": "encode",
        "comment": " Convert a `Value` into a prettified string. The first argument specifies\nthe amount of indentation in the resulting string.\n\n    person =\n        object\n          [ (\"name\", string \"Tom\")\n          , (\"age\", int 42)\n          ]\n\n    compact = encode 0 person\n    -- {\"name\":\"Tom\",\"age\":42}\n\n    readable = encode 4 person\n    -- {\n    --     \"name\": \"Tom\",\n    --     \"age\": 42\n    -- }\n",
        "type": "Int -> Json.Encode.Value -> String"
      },
      {
        "name": "float",
        "comment": " Encode a Float. `Infinity` and `NaN` are encoded as `null`.\n",
        "type": "Float -> Json.Encode.Value"
      },
      {
        "name": "int",
        "comment": "",
        "type": "Int -> Json.Encode.Value"
      },
      {
        "name": "list",
        "comment": "",
        "type": "List Json.Encode.Value -> Json.Encode.Value"
      },
      {
        "name": "null",
        "comment": "",
        "type": "Json.Encode.Value"
      },
      {
        "name": "object",
        "comment": "",
        "type": "List ( String, Json.Encode.Value ) -> Json.Encode.Value"
      },
      {
        "name": "string",
        "comment": "",
        "type": "String -> Json.Encode.Value"
      }
    ],
    "generated-with-elm-version": "0.17.0"
  },
  {
    "name": "String",
    "comment": " A built-in representation for efficient string manipulation. String literals\nare enclosed in `\"double quotes\"`. Strings are *not* lists of characters.\n\n# Basics\n@docs isEmpty, length, reverse, repeat\n\n# Building and Splitting\n@docs cons, uncons, fromChar, append, concat, split, join, words, lines\n\n# Get Substrings\n@docs slice, left, right, dropLeft, dropRight\n\n# Check for Substrings\n@docs contains, startsWith, endsWith, indexes, indices\n\n# Conversions\n@docs toInt, toFloat, toList, fromList\n\n# Formatting\nCosmetic operations such as padding with extra characters or trimming whitespace.\n\n@docs toUpper, toLower,\n      pad, padLeft, padRight,\n      trim, trimLeft, trimRight\n\n# Higher-Order Functions\n@docs map, filter, foldl, foldr, any, all\n",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "all",
        "comment": " Determine whether *all* characters satisfy a predicate.\n\n    all isDigit \"90210\" == True\n    all isDigit \"R2-D2\" == False\n    all isDigit \"heart\" == False\n",
        "type": "(Char -> Bool) -> String -> Bool"
      },
      {
        "name": "any",
        "comment": " Determine whether *any* characters satisfy a predicate.\n\n    any isDigit \"90210\" == True\n    any isDigit \"R2-D2\" == True\n    any isDigit \"heart\" == False\n",
        "type": "(Char -> Bool) -> String -> Bool"
      },
      {
        "name": "append",
        "comment": " Append two strings. You can also use [the `(++)` operator](Basics#++)\nto do this.\n\n    append \"butter\" \"fly\" == \"butterfly\"\n",
        "type": "String -> String -> String"
      },
      {
        "name": "concat",
        "comment": " Concatenate many strings into one.\n\n    concat [\"never\",\"the\",\"less\"] == \"nevertheless\"\n",
        "type": "List String -> String"
      },
      {
        "name": "cons",
        "comment": " Add a character to the beginning of a string.\n\n    cons 'T' \"he truth is out there\" == \"The truth is out there\"\n",
        "type": "Char -> String -> String"
      },
      {
        "name": "contains",
        "comment": " See if the second string contains the first one.\n\n    contains \"the\" \"theory\" == True\n    contains \"hat\" \"theory\" == False\n    contains \"THE\" \"theory\" == False\n\nUse [`Regex.contains`](Regex#contains) if you need something more flexible.\n",
        "type": "String -> String -> Bool"
      },
      {
        "name": "dropLeft",
        "comment": " Drop *n* characters from the left side of a string.\n\n    dropLeft 2 \"The Lone Gunmen\" == \"e Lone Gunmen\"\n",
        "type": "Int -> String -> String"
      },
      {
        "name": "dropRight",
        "comment": " Drop *n* characters from the right side of a string.\n\n    dropRight 2 \"Cigarette Smoking Man\" == \"Cigarette Smoking M\"\n",
        "type": "Int -> String -> String"
      },
      {
        "name": "endsWith",
        "comment": " See if the second string ends with the first one.\n\n    endsWith \"the\" \"theory\" == False\n    endsWith \"ory\" \"theory\" == True\n",
        "type": "String -> String -> Bool"
      },
      {
        "name": "filter",
        "comment": " Keep only the characters that satisfy the predicate.\n\n    filter isDigit \"R2-D2\" == \"22\"\n",
        "type": "(Char -> Bool) -> String -> String"
      },
      {
        "name": "foldl",
        "comment": " Reduce a string from the left.\n\n    foldl cons \"\" \"time\" == \"emit\"\n",
        "type": "(Char -> b -> b) -> b -> String -> b"
      },
      {
        "name": "foldr",
        "comment": " Reduce a string from the right.\n\n    foldr cons \"\" \"time\" == \"time\"\n",
        "type": "(Char -> b -> b) -> b -> String -> b"
      },
      {
        "name": "fromChar",
        "comment": " Create a string from a given character.\n\n    fromChar 'a' == \"a\"\n",
        "type": "Char -> String"
      },
      {
        "name": "fromList",
        "comment": " Convert a list of characters into a String. Can be useful if you\nwant to create a string primarily by consing, perhaps for decoding\nsomething.\n\n    fromList ['a','b','c'] == \"abc\"\n",
        "type": "List Char -> String"
      },
      {
        "name": "indexes",
        "comment": " Get all of the indexes for a substring in another string.\n\n    indexes \"i\" \"Mississippi\"   == [1,4,7,10]\n    indexes \"ss\" \"Mississippi\"  == [2,5]\n    indexes \"needle\" \"haystack\" == []\n",
        "type": "String -> String -> List Int"
      },
      {
        "name": "indices",
        "comment": " Alias for `indexes`. ",
        "type": "String -> String -> List Int"
      },
      {
        "name": "isEmpty",
        "comment": " Determine if a string is empty.\n\n    isEmpty \"\" == True\n    isEmpty \"the world\" == False\n",
        "type": "String -> Bool"
      },
      {
        "name": "join",
        "comment": " Put many strings together with a given separator.\n\n    join \"a\" [\"H\",\"w\",\"ii\",\"n\"]        == \"Hawaiian\"\n    join \" \" [\"cat\",\"dog\",\"cow\"]       == \"cat dog cow\"\n    join \"/\" [\"home\",\"evan\",\"Desktop\"] == \"home/evan/Desktop\"\n",
        "type": "String -> List String -> String"
      },
      {
        "name": "left",
        "comment": " Take *n* characters from the left side of a string.\n\n    left 2 \"Mulder\" == \"Mu\"\n",
        "type": "Int -> String -> String"
      },
      {
        "name": "length",
        "comment": " Get the length of a string.\n\n    length \"innumerable\" == 11\n    length \"\" == 0\n\n",
        "type": "String -> Int"
      },
      {
        "name": "lines",
        "comment": " Break a string into lines, splitting on newlines.\n\n    lines \"How are you?\\nGood?\" == [\"How are you?\", \"Good?\"]\n",
        "type": "String -> List String"
      },
      {
        "name": "map",
        "comment": " Transform every character in a string\n\n    map (\\c -> if c == '/' then '.' else c) \"a/b/c\" == \"a.b.c\"\n",
        "type": "(Char -> Char) -> String -> String"
      },
      {
        "name": "pad",
        "comment": " Pad a string on both sides until it has a given length.\n\n    pad 5 ' ' \"1\"   == \"  1  \"\n    pad 5 ' ' \"11\"  == \"  11 \"\n    pad 5 ' ' \"121\" == \" 121 \"\n",
        "type": "Int -> Char -> String -> String"
      },
      {
        "name": "padLeft",
        "comment": " Pad a string on the left until it has a given length.\n\n    padLeft 5 '.' \"1\"   == \"....1\"\n    padLeft 5 '.' \"11\"  == \"...11\"\n    padLeft 5 '.' \"121\" == \"..121\"\n",
        "type": "Int -> Char -> String -> String"
      },
      {
        "name": "padRight",
        "comment": " Pad a string on the right until it has a given length.\n\n    padRight 5 '.' \"1\"   == \"1....\"\n    padRight 5 '.' \"11\"  == \"11...\"\n    padRight 5 '.' \"121\" == \"121..\"\n",
        "type": "Int -> Char -> String -> String"
      },
      {
        "name": "repeat",
        "comment": " Repeat a string *n* times.\n\n    repeat 3 \"ha\" == \"hahaha\"\n",
        "type": "Int -> String -> String"
      },
      {
        "name": "reverse",
        "comment": " Reverse a string.\n\n    reverse \"stressed\" == \"desserts\"\n",
        "type": "String -> String"
      },
      {
        "name": "right",
        "comment": " Take *n* characters from the right side of a string.\n\n    right 2 \"Scully\" == \"ly\"\n",
        "type": "Int -> String -> String"
      },
      {
        "name": "slice",
        "comment": " Take a substring given a start and end index. Negative indexes\nare taken starting from the *end* of the list.\n\n    slice  7  9 \"snakes on a plane!\" == \"on\"\n    slice  0  6 \"snakes on a plane!\" == \"snakes\"\n    slice  0 -7 \"snakes on a plane!\" == \"snakes on a\"\n    slice -6 -1 \"snakes on a plane!\" == \"plane\"\n",
        "type": "Int -> Int -> String -> String"
      },
      {
        "name": "split",
        "comment": " Split a string using a given separator.\n\n    split \",\" \"cat,dog,cow\"        == [\"cat\",\"dog\",\"cow\"]\n    split \"/\" \"home/evan/Desktop/\" == [\"home\",\"evan\",\"Desktop\", \"\"]\n\nUse [`Regex.split`](Regex#split) if you need something more flexible.\n",
        "type": "String -> String -> List String"
      },
      {
        "name": "startsWith",
        "comment": " See if the second string starts with the first one.\n\n    startsWith \"the\" \"theory\" == True\n    startsWith \"ory\" \"theory\" == False\n",
        "type": "String -> String -> Bool"
      },
      {
        "name": "toFloat",
        "comment": " Try to convert a string into a float, failing on improperly formatted strings.\n\n    String.toFloat \"123\" == Ok 123.0\n    String.toFloat \"-42\" == Ok -42.0\n    String.toFloat \"3.1\" == Ok 3.1\n    String.toFloat \"31a\" == Err \"could not convert string '31a' to a Float\"\n\nIf you are extracting a number from some raw user input, you will typically\nwant to use [`Result.withDefault`](Result#withDefault) to handle bad data:\n\n    Result.withDefault 0 (String.toFloat \"42.5\") == 42.5\n    Result.withDefault 0 (String.toFloat \"cats\") == 0\n",
        "type": "String -> Result.Result String Float"
      },
      {
        "name": "toInt",
        "comment": " Try to convert a string into an int, failing on improperly formatted strings.\n\n    String.toInt \"123\" == Ok 123\n    String.toInt \"-42\" == Ok -42\n    String.toInt \"3.1\" == Err \"could not convert string '3.1' to an Int\"\n    String.toInt \"31a\" == Err \"could not convert string '31a' to an Int\"\n\nIf you are extracting a number from some raw user input, you will typically\nwant to use [`Result.withDefault`](Result#withDefault) to handle bad data:\n\n    Result.withDefault 0 (String.toInt \"42\") == 42\n    Result.withDefault 0 (String.toInt \"ab\") == 0\n",
        "type": "String -> Result.Result String Int"
      },
      {
        "name": "toList",
        "comment": " Convert a string to a list of characters.\n\n    toList \"abc\" == ['a','b','c']\n",
        "type": "String -> List Char"
      },
      {
        "name": "toLower",
        "comment": " Convert a string to all lower case. Useful for case-insensitive comparisons.\n\n   toLower \"X-FILES\" == \"x-files\"\n",
        "type": "String -> String"
      },
      {
        "name": "toUpper",
        "comment": " Convert a string to all upper case. Useful for case-insensitive comparisons\nand VIRTUAL YELLING.\n\n    toUpper \"skinner\" == \"SKINNER\"\n",
        "type": "String -> String"
      },
      {
        "name": "trim",
        "comment": " Get rid of whitespace on both sides of a string.\n\n    trim \"  hats  \\n\" == \"hats\"\n",
        "type": "String -> String"
      },
      {
        "name": "trimLeft",
        "comment": " Get rid of whitespace on the left of a string.\n\n    trimLeft \"  hats  \\n\" == \"hats  \\n\"\n",
        "type": "String -> String"
      },
      {
        "name": "trimRight",
        "comment": " Get rid of whitespace on the right of a string.\n\n    trimRight \"  hats  \\n\" == \"  hats\"\n",
        "type": "String -> String"
      },
      {
        "name": "uncons",
        "comment": " Split a non-empty string into its head and tail. This lets you\npattern match on strings exactly as you would with lists.\n\n    uncons \"abc\" == Just ('a',\"bc\")\n    uncons \"\"    == Nothing\n",
        "type": "String -> Maybe.Maybe ( Char, String )"
      },
      {
        "name": "words",
        "comment": " Break a string into words, splitting on chunks of whitespace.\n\n    words \"How are \\t you? \\n Good?\" == [\"How\",\"are\",\"you?\",\"Good?\"]\n",
        "type": "String -> List String"
      }
    ],
    "generated-with-elm-version": "0.17.0"
  },
  {
    "name": "Task",
    "comment": " Tasks make it easy to describe asynchronous operations that may fail, like\nHTTP requests or writing to a database. For more information, see the [Elm\ndocumentation on Tasks](http://guide.elm-lang.org/error_handling/task.html).\n\n# Basics\n@docs Task, succeed, fail\n\n# Mapping\n@docs map, map2, map3, map4, map5, andMap\n\n# Chaining\n@docs andThen, sequence\n\n# Errors\n@docs onError, mapError, toMaybe, fromMaybe, toResult, fromResult\n\n# Commands\n@docs perform\n\n",
    "aliases": [
      {
        "name": "Task",
        "comment": " Represents asynchronous effects that may fail. It is useful for stuff like\nHTTP.\n\nFor example, maybe we have a task with the type (`Task String User`). This means\nthat when we perform the task, it will either fail with a `String` message or\nsucceed with a `User`. So this could represent a task that is asking a server\nfor a certain user.\n",
        "args": [
          "err",
          "ok"
        ],
        "type": "Platform.Task err ok"
      }
    ],
    "types": [],
    "values": [
      {
        "name": "andMap",
        "comment": " Put the results of two tasks together. If either task fails, the whole\nthing fails. It also runs in order so the first task will be completely\nfinished before the second task starts.\n\nThis function makes it possible to chain tons of tasks together and pipe them\nall into a single function.\n\n    (f `map` task1 `andMap` task2 `andMap` task3) -- map3 f task1 task2 task3\n",
        "type": "Task.Task x (a -> b) -> Task.Task x a -> Task.Task x b"
      },
      {
        "name": "andThen",
        "comment": " Chain together a task and a callback. The first task will run, and if it is\nsuccessful, you give the result to the callback resulting in another task. This\ntask then gets run.\n\n    succeed 2 `andThen` (\\n -> succeed (n + 2)) -- succeed 4\n\nThis is useful for chaining tasks together. Maybe you need to get a user from\nyour servers *and then* lookup their picture once you know their name.\n",
        "type": "Task.Task x a -> (a -> Task.Task x b) -> Task.Task x b"
      },
      {
        "name": "fail",
        "comment": " A task that fails immediately when run.\n\n    fail \"file not found\" : Task String a\n",
        "type": "x -> Task.Task x a"
      },
      {
        "name": "fromMaybe",
        "comment": " If you are chaining together a bunch of tasks, it may be useful to treat\na maybe value like a task.\n\n    fromMaybe \"file not found\" Nothing   -- fail \"file not found\"\n    fromMaybe \"file not found\" (Just 42) -- succeed 42\n",
        "type": "x -> Maybe.Maybe a -> Task.Task x a"
      },
      {
        "name": "fromResult",
        "comment": " If you are chaining together a bunch of tasks, it may be useful to treat\na result like a task.\n\n    fromResult (Err \"file not found\") -- fail \"file not found\"\n    fromResult (Ok 42)                -- succeed 42\n",
        "type": "Result.Result x a -> Task.Task x a"
      },
      {
        "name": "map",
        "comment": " Transform a task.\n\n    map sqrt (succeed 9) -- succeed 3\n",
        "type": "(a -> b) -> Task.Task x a -> Task.Task x b"
      },
      {
        "name": "map2",
        "comment": " Put the results of two tasks together. If either task fails, the whole\nthing fails. It also runs in order so the first task will be completely\nfinished before the second task starts.\n\n    map2 (+) (succeed 9) (succeed 3) -- succeed 12\n",
        "type": "(a -> b -> result) -> Task.Task x a -> Task.Task x b -> Task.Task x result"
      },
      {
        "name": "map3",
        "comment": "",
        "type": "(a -> b -> c -> result) -> Task.Task x a -> Task.Task x b -> Task.Task x c -> Task.Task x result"
      },
      {
        "name": "map4",
        "comment": "",
        "type": "(a -> b -> c -> d -> result) -> Task.Task x a -> Task.Task x b -> Task.Task x c -> Task.Task x d -> Task.Task x result"
      },
      {
        "name": "map5",
        "comment": "",
        "type": "(a -> b -> c -> d -> e -> result) -> Task.Task x a -> Task.Task x b -> Task.Task x c -> Task.Task x d -> Task.Task x e -> Task.Task x result"
      },
      {
        "name": "mapError",
        "comment": " Transform the error value. This can be useful if you need a bunch of error\ntypes to match up.\n\n    type Error = Http Http.Error | WebGL WebGL.Error\n\n    getResources : Task Error Resource\n    getResources =\n      sequence [ mapError Http serverTask, mapError WebGL textureTask ]\n",
        "type": "(x -> y) -> Task.Task x a -> Task.Task y a"
      },
      {
        "name": "onError",
        "comment": " Recover from a failure in a task. If the given task fails, we use the\ncallback to recover.\n\n    fail \"file not found\" `onError` (\\msg -> succeed 42) -- succeed 42\n    succeed 9 `onError` (\\msg -> succeed 42)             -- succeed 9\n",
        "type": "Task.Task x a -> (x -> Task.Task y a) -> Task.Task y a"
      },
      {
        "name": "perform",
        "comment": " Command the runtime system to perform a task. The most important argument\nis the `Task` which describes what you want to happen. But you also need to\nprovide functions to tag the two possible outcomes of the task. It can fail or\nsucceed, but either way, you need to have a message to feed back into your\napplication.\n",
        "type": "(x -> msg) -> (a -> msg) -> Task.Task x a -> Platform.Cmd.Cmd msg"
      },
      {
        "name": "sequence",
        "comment": " Start with a list of tasks, and turn them into a single task that returns a\nlist. The tasks will be run in order one-by-one and if any task fails the whole\nsequence fails.\n\n    sequence [ succeed 1, succeed 2 ] -- succeed [ 1, 2 ]\n\nThis can be useful if you need to make a bunch of HTTP requests one-by-one.\n",
        "type": "List (Task.Task x a) -> Task.Task x (List a)"
      },
      {
        "name": "succeed",
        "comment": " A task that succeeds immediately when run.\n\n    succeed 42    -- results in 42\n",
        "type": "a -> Task.Task x a"
      },
      {
        "name": "toMaybe",
        "comment": " Translate a task that can fail into a task that can never fail, by\nconverting any failure into `Nothing` and any success into `Just` something.\n\n    toMaybe (fail \"file not found\") -- succeed Nothing\n    toMaybe (succeed 42)            -- succeed (Just 42)\n\nThis means you can handle the error with the `Maybe` module instead.\n",
        "type": "Task.Task x a -> Task.Task never (Maybe.Maybe a)"
      },
      {
        "name": "toResult",
        "comment": " Translate a task that can fail into a task that can never fail, by\nconverting any failure into `Err` something and any success into `Ok` something.\n\n    toResult (fail \"file not found\") -- succeed (Err \"file not found\")\n    toResult (succeed 42)            -- succeed (Ok 42)\n\nThis means you can handle the error with the `Result` module instead.\n",
        "type": "Task.Task x a -> Task.Task never (Result.Result x a)"
      }
    ],
    "generated-with-elm-version": "0.17.0"
  },
  {
    "name": "Array",
    "comment": " A library for fast immutable arrays. The elements in an array must have the\nsame type. The arrays are implemented in Relaxed Radix Balanced-Trees for fast\nreads, updates, and appends.\n\n# Arrays\n@docs Array\n\n# Creating Arrays\n@docs empty, repeat, initialize, fromList\n\n# Basics\n@docs isEmpty, length, push, append\n\n# Get and Set\n@docs get, set\n\n# Taking Arrays Apart\n@docs slice, toList, toIndexedList\n\n# Mapping, Filtering, and Folding\n@docs map, indexedMap, filter, foldl, foldr\n",
    "aliases": [],
    "types": [
      {
        "name": "Array",
        "comment": " Representation of fast immutable arrays. You can create arrays of integers\n(`Array Int`) or strings (`Array String`) or any other type of value you can\ndream up.\n",
        "args": [
          "a"
        ],
        "cases": []
      }
    ],
    "values": [
      {
        "name": "append",
        "comment": " Append two arrays to a new one.\n\n    append (repeat 2 42) (repeat 3 81) == fromList [42,42,81,81,81]\n",
        "type": "Array.Array a -> Array.Array a -> Array.Array a"
      },
      {
        "name": "empty",
        "comment": " Return an empty array.\n\n    length empty == 0\n",
        "type": "Array.Array a"
      },
      {
        "name": "filter",
        "comment": " Keep only elements that satisfy the predicate:\n\n    filter isEven (fromList [1..6]) == (fromList [2,4,6])\n",
        "type": "(a -> Bool) -> Array.Array a -> Array.Array a"
      },
      {
        "name": "foldl",
        "comment": " Reduce an array from the left. Read `foldl` as &ldquo;fold from the left&rdquo;.\n\n    foldl (::) [] (fromList [1,2,3]) == [3,2,1]\n",
        "type": "(a -> b -> b) -> b -> Array.Array a -> b"
      },
      {
        "name": "foldr",
        "comment": " Reduce an array from the right. Read `foldr` as &ldquo;fold from the right&rdquo;.\n\n    foldr (+) 0 (repeat 3 5) == 15\n",
        "type": "(a -> b -> b) -> b -> Array.Array a -> b"
      },
      {
        "name": "fromList",
        "comment": " Create an array from a list.\n",
        "type": "List a -> Array.Array a"
      },
      {
        "name": "get",
        "comment": " Return Just the element at the index or Nothing if the index is out of range.\n\n    get  0 (fromList [0,1,2]) == Just 0\n    get  2 (fromList [0,1,2]) == Just 2\n    get  5 (fromList [0,1,2]) == Nothing\n    get -1 (fromList [0,1,2]) == Nothing\n\n",
        "type": "Int -> Array.Array a -> Maybe.Maybe a"
      },
      {
        "name": "indexedMap",
        "comment": " Apply a function on every element with its index as first argument.\n\n    indexedMap (*) (fromList [5,5,5]) == fromList [0,5,10]\n",
        "type": "(Int -> a -> b) -> Array.Array a -> Array.Array b"
      },
      {
        "name": "initialize",
        "comment": " Initialize an array. `initialize n f` creates an array of length `n` with\nthe element at index `i` initialized to the result of `(f i)`.\n\n    initialize 4 identity    == fromList [0,1,2,3]\n    initialize 4 (\\n -> n*n) == fromList [0,1,4,9]\n    initialize 4 (always 0)  == fromList [0,0,0,0]\n",
        "type": "Int -> (Int -> a) -> Array.Array a"
      },
      {
        "name": "isEmpty",
        "comment": " Determine if an array is empty.\n\n    isEmpty empty == True\n",
        "type": "Array.Array a -> Bool"
      },
      {
        "name": "length",
        "comment": " Return the length of an array.\n\n    length (fromList [1,2,3]) == 3\n",
        "type": "Array.Array a -> Int"
      },
      {
        "name": "map",
        "comment": " Apply a function on every element in an array.\n\n    map sqrt (fromList [1,4,9]) == fromList [1,2,3]\n",
        "type": "(a -> b) -> Array.Array a -> Array.Array b"
      },
      {
        "name": "push",
        "comment": " Push an element to the end of an array.\n\n    push 3 (fromList [1,2]) == fromList [1,2,3]\n",
        "type": "a -> Array.Array a -> Array.Array a"
      },
      {
        "name": "repeat",
        "comment": " Creates an array with a given length, filled with a default element.\n\n    repeat 5 0     == fromList [0,0,0,0,0]\n    repeat 3 \"cat\" == fromList [\"cat\",\"cat\",\"cat\"]\n\nNotice that `repeat 3 x` is the same as `initialize 3 (always x)`.\n",
        "type": "Int -> a -> Array.Array a"
      },
      {
        "name": "set",
        "comment": " Set the element at a particular index. Returns an updated array.\nIf the index is out of range, the array is unaltered.\n\n    set 1 7 (fromList [1,2,3]) == fromList [1,7,3]\n",
        "type": "Int -> a -> Array.Array a -> Array.Array a"
      },
      {
        "name": "slice",
        "comment": " Get a sub-section of an array: `(slice start end array)`. The `start` is a\nzero-based index where we will start our slice. The `end` is a zero-based index\nthat indicates the end of the slice. The slice extracts up to but not including\n`end`.\n\n    slice  0  3 (fromList [0,1,2,3,4]) == fromList [0,1,2]\n    slice  1  4 (fromList [0,1,2,3,4]) == fromList [1,2,3]\n\nBoth the `start` and `end` indexes can be negative, indicating an offset from\nthe end of the array.\n\n    slice  1 -1 (fromList [0,1,2,3,4]) == fromList [1,2,3]\n    slice -2  5 (fromList [0,1,2,3,4]) == fromList [3,4]\n\nThis makes it pretty easy to `pop` the last element off of an array: `slice 0 -1 array`\n",
        "type": "Int -> Int -> Array.Array a -> Array.Array a"
      },
      {
        "name": "toIndexedList",
        "comment": " Create an indexed list from an array. Each element of the array will be\npaired with its index.\n\n    toIndexedList (fromList [\"cat\",\"dog\"]) == [(0,\"cat\"), (1,\"dog\")]\n",
        "type": "Array.Array a -> List ( Int, a )"
      },
      {
        "name": "toList",
        "comment": " Create a list of elements from an array.\n\n    toList (fromList [3,5,8]) == [3,5,8]\n",
        "type": "Array.Array a -> List a"
      }
    ],
    "generated-with-elm-version": "0.17.0"
  },
  {
    "name": "Regex",
    "comment": " A library for working with regular expressions. It uses [the\nsame kind of regular expressions accepted by JavaScript](https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/Regular_Expressions).\n\n# Create\n@docs Regex, regex, escape, caseInsensitive\n\n# Helpful Data Structures\n\nThese data structures are needed to help define functions like [`find`](#find)\nand [`replace`](#replace).\n\n@docs HowMany, Match\n\n# Use\n@docs contains, find, replace, split\n\n",
    "aliases": [
      {
        "name": "Match",
        "comment": " A `Match` represents all of the details about a particular match in a string.\nHere are details on each field:\n\n  * `match` &mdash; the full string of the match.\n  * `submatches` &mdash; a regex might have [subpatterns, surrounded by\n    parentheses](https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/Regular_Expressions#Using_Parenthesized_Substring_Matches).\n    If there are N subpatterns, there will be N elements in the `submatches` list.\n    Each submatch in this list is a `Maybe` because not all subpatterns may trigger.\n    For example, `(regex \"(a+)|(b+)\")` will either match many `a`&rsquo;s or\n    many `b`&rsquo;s, but never both.\n  * `index` &mdash; the index of the match in the original string.\n  * `number` &mdash; if you find many matches, you can think of each one\n    as being labeled with a `number` starting at one. So the first time you\n    find a match, that is match `number` one. Second time is match `number` two.\n    This is useful when paired with `replace All` if replacement is dependent on how\n    many times a pattern has appeared before.\n",
        "args": [],
        "type": "{ match : String , submatches : List (Maybe.Maybe String) , index : Int , number : Int }"
      }
    ],
    "types": [
      {
        "name": "HowMany",
        "comment": " `HowMany` is used to specify how many matches you want to make. So\n`replace All` would replace every match, but `replace (AtMost 2)` would\nreplace at most two matches (i.e. zero, one, two, but never three or more).\n",
        "args": [],
        "cases": [
          [
            "All",
            []
          ],
          [
            "AtMost",
            [
              "Int"
            ]
          ]
        ]
      },
      {
        "name": "Regex",
        "comment": " A regular expression, describing a certain set of strings.\n",
        "args": [],
        "cases": []
      }
    ],
    "values": [
      {
        "name": "caseInsensitive",
        "comment": " Make a regex case insensitive ",
        "type": "Regex.Regex -> Regex.Regex"
      },
      {
        "name": "contains",
        "comment": " Check to see if a Regex is contained in a string.\n\n    contains (regex \"123\") \"12345\" == True\n    contains (regex \"b+\") \"aabbcc\" == True\n\n    contains (regex \"789\") \"12345\" == False\n    contains (regex \"z+\") \"aabbcc\" == False\n",
        "type": "Regex.Regex -> String -> Bool"
      },
      {
        "name": "escape",
        "comment": " Escape strings to be regular expressions, making all special characters\nsafe. So `regex (escape \"^a+\")` will match exactly `\"^a+\"` instead of a series\nof `a`&rsquo;s that start at the beginning of the line.\n",
        "type": "String -> String"
      },
      {
        "name": "find",
        "comment": " Find matches in a string:\n\n    findTwoCommas = find (AtMost 2) (regex \",\")\n\n      -- map .index (findTwoCommas \"a,b,c,d,e\") == [1,3]\n      -- map .index (findTwoCommas \"a b c d e\") == []\n\n    places = find All (regex \"[oi]n a (\\\\w+)\") \"I am on a boat in a lake.\"\n\n      -- map .match places == [\"on a boat\", \"in a lake\"]\n      -- map .submatches places == [ [Just \"boat\"], [Just \"lake\"] ]\n",
        "type": "Regex.HowMany -> Regex.Regex -> String -> List Regex.Match"
      },
      {
        "name": "regex",
        "comment": " Create a Regex that matches patterns [as specified in JavaScript](https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/Regular_Expressions#Writing_a_Regular_Expression_Pattern).\n\nBe careful to escape backslashes properly! For example, `\"\\w\"` is escaping the\nletter `w` which is probably not what you want. You probably want `\"\\\\w\"`\ninstead, which escapes the backslash.\n",
        "type": "String -> Regex.Regex"
      },
      {
        "name": "replace",
        "comment": " Replace matches. The function from `Match` to `String` lets\nyou use the details of a specific match when making replacements.\n\n    devowel = replace All (regex \"[aeiou]\") (\\_ -> \"\")\n\n      -- devowel \"The quick brown fox\" == \"Th qck brwn fx\"\n\n    reverseWords = replace All (regex \"\\\\w+\") (\\{match} -> String.reverse match)\n\n      -- reverseWords \"deliver mined parts\" == \"reviled denim strap\"\n",
        "type": "Regex.HowMany -> Regex.Regex -> (Regex.Match -> String) -> String -> String"
      },
      {
        "name": "split",
        "comment": " Split a string, using the regex as the separator.\n\n    split (AtMost 1) (regex \",\") \"tom,99,90,85\" == [\"tom\",\"99,90,85\"]\n\n    split All (regex \",\") \"a,b,c,d\" == [\"a\",\"b\",\"c\",\"d\"]\n",
        "type": "Regex.HowMany -> Regex.Regex -> String -> List String"
      }
    ],
    "generated-with-elm-version": "0.17.0"
  },
  {
    "name": "Result",
    "comment": " A `Result` is the result of a computation that may fail. This is a great\nway to manage errors in Elm.\n\n# Type and Constructors\n@docs Result\n\n# Mapping\n@docs map, map2, map3, map4, map5\n\n# Chaining\n@docs andThen\n\n# Handling Errors\n@docs withDefault, toMaybe, fromMaybe, formatError\n",
    "aliases": [],
    "types": [
      {
        "name": "Result",
        "comment": " A `Result` is either `Ok` meaning the computation succeeded, or it is an\n`Err` meaning that there was some failure.\n",
        "args": [
          "error",
          "value"
        ],
        "cases": [
          [
            "Ok",
            [
              "value"
            ]
          ],
          [
            "Err",
            [
              "error"
            ]
          ]
        ]
      }
    ],
    "values": [
      {
        "name": "andThen",
        "comment": " Chain together a sequence of computations that may fail. It is helpful\nto see its definition:\n\n    andThen : Result e a -> (a -> Result e b) -> Result e b\n    andThen result callback =\n        case result of\n          Ok value -> callback value\n          Err msg -> Err msg\n\nThis means we only continue with the callback if things are going well. For\nexample, say you need to use (`toInt : String -> Result String Int`) to parse\na month and make sure it is between 1 and 12:\n\n    toValidMonth : Int -> Result String Int\n    toValidMonth month =\n        if month >= 1 && month <= 12\n            then Ok month\n            else Err \"months must be between 1 and 12\"\n\n    toMonth : String -> Result String Int\n    toMonth rawString =\n        toInt rawString `andThen` toValidMonth\n\n    -- toMonth \"4\" == Ok 4\n    -- toMonth \"9\" == Ok 9\n    -- toMonth \"a\" == Err \"cannot parse to an Int\"\n    -- toMonth \"0\" == Err \"months must be between 1 and 12\"\n\nThis allows us to come out of a chain of operations with quite a specific error\nmessage. It is often best to create a custom type that explicitly represents\nthe exact ways your computation may fail. This way it is easy to handle in your\ncode.\n",
        "type": "Result.Result x a -> (a -> Result.Result x b) -> Result.Result x b"
      },
      {
        "name": "formatError",
        "comment": " Format the error value of a result. If the result is `Ok`, it stays exactly\nthe same, but if the result is an `Err` we will format the error. For example,\nsay the errors we get have too much information:\n\n    parseInt : String -> Result ParseError Int\n\n    type alias ParseError =\n        { message : String\n        , code : Int\n        , position : (Int,Int)\n        }\n\n    formatError .message (parseInt \"123\") == Ok 123\n    formatError .message (parseInt \"abc\") == Err \"char 'a' is not a number\"\n",
        "type": "(error -> error') -> Result.Result error a -> Result.Result error' a"
      },
      {
        "name": "fromMaybe",
        "comment": " Convert from a simple `Maybe` to interact with some code that primarily\nuses `Results`.\n\n    parseInt : String -> Maybe Int\n\n    resultParseInt : String -> Result String Int\n    resultParseInt string =\n        fromMaybe (\"error parsing string: \" ++ toString string) (parseInt string)\n",
        "type": "x -> Maybe.Maybe a -> Result.Result x a"
      },
      {
        "name": "map",
        "comment": " Apply a function to a result. If the result is `Ok`, it will be converted.\nIf the result is an `Err`, the same error value will propagate through.\n\n    map sqrt (Ok 4.0)          == Ok 2.0\n    map sqrt (Err \"bad input\") == Err \"bad input\"\n",
        "type": "(a -> value) -> Result.Result x a -> Result.Result x value"
      },
      {
        "name": "map2",
        "comment": " Apply a function to two results, if both results are `Ok`. If not,\nthe first argument which is an `Err` will propagate through.\n\n    map2 (+) (String.toInt \"1\") (String.toInt \"2\") == Ok 3\n    map2 (+) (String.toInt \"1\") (String.toInt \"y\") == Err \"could not convert string 'y' to an Int\"\n    map2 (+) (String.toInt \"x\") (String.toInt \"y\") == Err \"could not convert string 'x' to an Int\"\n",
        "type": "(a -> b -> value) -> Result.Result x a -> Result.Result x b -> Result.Result x value"
      },
      {
        "name": "map3",
        "comment": "",
        "type": "(a -> b -> c -> value) -> Result.Result x a -> Result.Result x b -> Result.Result x c -> Result.Result x value"
      },
      {
        "name": "map4",
        "comment": "",
        "type": "(a -> b -> c -> d -> value) -> Result.Result x a -> Result.Result x b -> Result.Result x c -> Result.Result x d -> Result.Result x value"
      },
      {
        "name": "map5",
        "comment": "",
        "type": "(a -> b -> c -> d -> e -> value) -> Result.Result x a -> Result.Result x b -> Result.Result x c -> Result.Result x d -> Result.Result x e -> Result.Result x value"
      },
      {
        "name": "toMaybe",
        "comment": " Convert to a simpler `Maybe` if the actual error message is not needed or\nyou need to interact with some code that primarily uses maybes.\n\n    parseInt : String -> Result ParseError Int\n\n    maybeParseInt : String -> Maybe Int\n    maybeParseInt string =\n        toMaybe (parseInt string)\n",
        "type": "Result.Result x a -> Maybe.Maybe a"
      },
      {
        "name": "withDefault",
        "comment": " If the result is `Ok` return the value, but if the result is an `Err` then\nreturn a given default value. The following examples try to parse integers.\n\n    Result.withDefault 0 (String.toInt \"123\") == 123\n    Result.withDefault 0 (String.toInt \"abc\") == 0\n",
        "type": "a -> Result.Result x a -> a"
      }
    ],
    "generated-with-elm-version": "0.17.0"
  },
  {
    "name": "List",
    "comment": " A library for manipulating lists of values. Every value in a\nlist must have the same type.\n\n# Basics\n@docs isEmpty, length, reverse, member\n\n# Sub-lists\n@docs head, tail, filter, take, drop\n\n# Putting Lists Together\n@docs repeat, (::), append, concat, intersperse\n\n# Taking Lists Apart\n@docs partition, unzip\n\n# Mapping\n@docs map, map2, map3, map4, map5\n\nIf you can think of a legitimate use of `mapN` where `N` is 6 or more, please\nlet us know on [the list](https://groups.google.com/forum/#!forum/elm-discuss).\nThe current sentiment is that it is already quite error prone once you get to\n4 and possibly should be approached another way.\n\n# Special Maps\n@docs filterMap, concatMap, indexedMap\n\n# Folding\n@docs foldr, foldl\n\n# Special Folds\n@docs sum, product, maximum, minimum, all, any, scanl\n\n# Sorting\n@docs sort, sortBy, sortWith\n\n",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "::",
        "comment": " Add an element to the front of a list. Pronounced *cons*.\n\n    1 :: [2,3] == [1,2,3]\n    1 :: [] == [1]\n",
        "type": "a -> List a -> List a",
        "associativity": "right",
        "precedence": 5
      },
      {
        "name": "all",
        "comment": " Determine if all elements satisfy the predicate.\n\n    all isEven [2,4] == True\n    all isEven [2,3] == False\n    all isEven [] == True\n",
        "type": "(a -> Bool) -> List a -> Bool"
      },
      {
        "name": "any",
        "comment": " Determine if any elements satisfy the predicate.\n\n    any isEven [2,3] == True\n    any isEven [1,3] == False\n    any isEven [] == False\n",
        "type": "(a -> Bool) -> List a -> Bool"
      },
      {
        "name": "append",
        "comment": " Put two lists together.\n\n    append [1,1,2] [3,5,8] == [1,1,2,3,5,8]\n    append ['a','b'] ['c'] == ['a','b','c']\n\nYou can also use [the `(++)` operator](Basics#++) to append lists.\n",
        "type": "List a -> List a -> List a"
      },
      {
        "name": "concat",
        "comment": " Concatenate a bunch of lists into a single list:\n\n    concat [[1,2],[3],[4,5]] == [1,2,3,4,5]\n",
        "type": "List (List a) -> List a"
      },
      {
        "name": "concatMap",
        "comment": " Map a given function onto a list and flatten the resulting lists.\n\n    concatMap f xs == concat (map f xs)\n",
        "type": "(a -> List b) -> List a -> List b"
      },
      {
        "name": "drop",
        "comment": " Drop the first *n* members of a list.\n\n    drop 2 [1,2,3,4] == [3,4]\n",
        "type": "Int -> List a -> List a"
      },
      {
        "name": "filter",
        "comment": " Keep only elements that satisfy the predicate.\n\n    filter isEven [1..6] == [2,4,6]\n",
        "type": "(a -> Bool) -> List a -> List a"
      },
      {
        "name": "filterMap",
        "comment": " Apply a function that may succeed to all values in the list, but only keep\nthe successes.\n\n    onlyTeens =\n      filterMap isTeen [3, 15, 12, 18, 24] == [15, 18]\n\n    isTeen : Int -> Maybe Int\n    isTeen n =\n      if 13 <= n && n <= 19 then\n        Just n\n\n      else\n        Nothing\n",
        "type": "(a -> Maybe.Maybe b) -> List a -> List b"
      },
      {
        "name": "foldl",
        "comment": " Reduce a list from the left.\n\n    foldl (::) [] [1,2,3] == [3,2,1]\n",
        "type": "(a -> b -> b) -> b -> List a -> b"
      },
      {
        "name": "foldr",
        "comment": " Reduce a list from the right.\n\n    foldr (+) 0 [1,2,3] == 6\n",
        "type": "(a -> b -> b) -> b -> List a -> b"
      },
      {
        "name": "head",
        "comment": " Extract the first element of a list.\n\n    head [1,2,3] == Just 1\n    head [] == Nothing\n",
        "type": "List a -> Maybe.Maybe a"
      },
      {
        "name": "indexedMap",
        "comment": " Same as `map` but the function is also applied to the index of each\nelement (starting at zero).\n\n    indexedMap (,) [\"Tom\",\"Sue\",\"Bob\"] == [ (0,\"Tom\"), (1,\"Sue\"), (2,\"Bob\") ]\n",
        "type": "(Int -> a -> b) -> List a -> List b"
      },
      {
        "name": "intersperse",
        "comment": " Places the given value between all members of the given list.\n\n    intersperse \"on\" [\"turtles\",\"turtles\",\"turtles\"] == [\"turtles\",\"on\",\"turtles\",\"on\",\"turtles\"]\n",
        "type": "a -> List a -> List a"
      },
      {
        "name": "isEmpty",
        "comment": " Determine if a list is empty.\n\n    isEmpty [] == True\n",
        "type": "List a -> Bool"
      },
      {
        "name": "length",
        "comment": " Determine the length of a list.\n\n    length [1,2,3] == 3\n",
        "type": "List a -> Int"
      },
      {
        "name": "map",
        "comment": " Apply a function to every element of a list.\n\n    map sqrt [1,4,9] == [1,2,3]\n\n    map not [True,False,True] == [False,True,False]\n",
        "type": "(a -> b) -> List a -> List b"
      },
      {
        "name": "map2",
        "comment": " Combine two lists, combining them with the given function.\nIf one list is longer, the extra elements are dropped.\n\n    map2 (+) [1,2,3] [1,2,3,4] == [2,4,6]\n\n    map2 (,) [1,2,3] ['a','b'] == [ (1,'a'), (2,'b') ]\n\n    pairs : List a -> List b -> List (a,b)\n    pairs lefts rights =\n        map2 (,) lefts rights\n",
        "type": "(a -> b -> result) -> List a -> List b -> List result"
      },
      {
        "name": "map3",
        "comment": "",
        "type": "(a -> b -> c -> result) -> List a -> List b -> List c -> List result"
      },
      {
        "name": "map4",
        "comment": "",
        "type": "(a -> b -> c -> d -> result) -> List a -> List b -> List c -> List d -> List result"
      },
      {
        "name": "map5",
        "comment": "",
        "type": "(a -> b -> c -> d -> e -> result) -> List a -> List b -> List c -> List d -> List e -> List result"
      },
      {
        "name": "maximum",
        "comment": " Find the maximum element in a non-empty list.\n\n    maximum [1,4,2] == Just 4\n    maximum []      == Nothing\n",
        "type": "List comparable -> Maybe.Maybe comparable"
      },
      {
        "name": "member",
        "comment": " Figure out whether a list contains a value.\n\n    member 9 [1,2,3,4] == False\n    member 4 [1,2,3,4] == True\n",
        "type": "a -> List a -> Bool"
      },
      {
        "name": "minimum",
        "comment": " Find the minimum element in a non-empty list.\n\n    minimum [3,2,1] == Just 1\n    minimum []      == Nothing\n",
        "type": "List comparable -> Maybe.Maybe comparable"
      },
      {
        "name": "partition",
        "comment": " Partition a list based on a predicate. The first list contains all values\nthat satisfy the predicate, and the second list contains all the value that do\nnot.\n\n    partition (\\x -> x < 3) [0..5] == ([0,1,2], [3,4,5])\n    partition isEven        [0..5] == ([0,2,4], [1,3,5])\n",
        "type": "(a -> Bool) -> List a -> ( List a, List a )"
      },
      {
        "name": "product",
        "comment": " Get the product of the list elements.\n\n    product [1..4] == 24\n",
        "type": "List number -> number"
      },
      {
        "name": "repeat",
        "comment": " Create a list with *n* copies of a value:\n\n    repeat 3 (0,0) == [(0,0),(0,0),(0,0)]\n",
        "type": "Int -> a -> List a"
      },
      {
        "name": "reverse",
        "comment": " Reverse a list.\n\n    reverse [1..4] == [4,3,2,1]\n",
        "type": "List a -> List a"
      },
      {
        "name": "scanl",
        "comment": " Reduce a list from the left, building up all of the intermediate results into a list.\n\n    scanl (+) 0 [1,2,3,4] == [0,1,3,6,10]\n",
        "type": "(a -> b -> b) -> b -> List a -> List b"
      },
      {
        "name": "sort",
        "comment": " Sort values from lowest to highest\n\n    sort [3,1,5] == [1,3,5]\n",
        "type": "List comparable -> List comparable"
      },
      {
        "name": "sortBy",
        "comment": " Sort values by a derived property.\n\n    alice = { name=\"Alice\", height=1.62 }\n    bob   = { name=\"Bob\"  , height=1.85 }\n    chuck = { name=\"Chuck\", height=1.76 }\n\n    sortBy .name   [chuck,alice,bob] == [alice,bob,chuck]\n    sortBy .height [chuck,alice,bob] == [alice,chuck,bob]\n\n    sortBy String.length [\"mouse\",\"cat\"] == [\"cat\",\"mouse\"]\n",
        "type": "(a -> comparable) -> List a -> List a"
      },
      {
        "name": "sortWith",
        "comment": " Sort values with a custom comparison function.\n\n    sortWith flippedComparison [1..5] == [5,4,3,2,1]\n\n    flippedComparison a b =\n        case compare a b of\n          LT -> GT\n          EQ -> EQ\n          GT -> LT\n\nThis is also the most general sort function, allowing you\nto define any other: `sort == sortWith compare`\n",
        "type": "(a -> a -> Basics.Order) -> List a -> List a"
      },
      {
        "name": "sum",
        "comment": " Get the sum of the list elements.\n\n    sum [1..4] == 10\n",
        "type": "List number -> number"
      },
      {
        "name": "tail",
        "comment": " Extract the rest of the list.\n\n    tail [1,2,3] == Just [2,3]\n    tail [] == Nothing\n",
        "type": "List a -> Maybe.Maybe (List a)"
      },
      {
        "name": "take",
        "comment": " Take the first *n* members of a list.\n\n    take 2 [1,2,3,4] == [1,2]\n",
        "type": "Int -> List a -> List a"
      },
      {
        "name": "unzip",
        "comment": " Decompose a list of tuples into a tuple of lists.\n\n    unzip [(0, True), (17, False), (1337, True)] == ([0,17,1337], [True,False,True])\n",
        "type": "List ( a, b ) -> ( List a, List b )"
      }
    ],
    "generated-with-elm-version": "0.17.0"
  },
  {
    "name": "Platform",
    "comment": "\n\n# Programs\n@docs Program\n\n# Platform Internals\n\n## Tasks and Processes\n@docs Task, ProcessId\n\n## Effect Manager Helpers\n\nAn extremely tiny portion of library authors should ever write effect managers.\nFundamentally, Elm needs maybe 10 of them total. I get that people are smart,\ncurious, etc. but that is not a substitute for a legitimate reason to make an\neffect manager. Do you have an *organic need* this fills? Or are you just\ncurious? Public discussions of your explorations should be framed accordingly.\n\n@docs Router, sendToApp, sendToSelf\n",
    "aliases": [],
    "types": [
      {
        "name": "ProcessId",
        "comment": " Head over to the documentation for the [`Process`](Process) module for\ninformation on this. It is only defined here because it is a platform\nprimitive.\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Program",
        "comment": " Every Elm project will define `main` to be some sort of `Program`. A\n`Program` value captures all the details needed to manage your application,\nincluding how to initialize things, how to respond to events, etc.\n\nThe type of a `Program` includes a `flags` type variable which describes the\ndata we need to start a program. So say our program needs to be given a `userID`\nand `token` to get started:\n\n    MyApp.main : Program { userID : String, token : Int }\n\nSo when we initialize this program in JavaScript, we can give the necessary flags\nreally easily!\n\n```javascript\nElm.MyApp.fullscreen({\n    userID: \"Tom\",\n    token: 42\n});\n```\n",
        "args": [
          "flags"
        ],
        "cases": []
      },
      {
        "name": "Router",
        "comment": " An effect manager has access to a “router” that routes messages between\nthe main app and your individual effect manager.\n",
        "args": [
          "appMsg",
          "selfMsg"
        ],
        "cases": []
      },
      {
        "name": "Task",
        "comment": " Head over to the documentation for the [`Task`](Task) module for more\ninformation on this. It is only defined here because it is a platform\nprimitive.\n",
        "args": [
          "err",
          "ok"
        ],
        "cases": []
      }
    ],
    "values": [
      {
        "name": "sendToApp",
        "comment": " Send the router a message for the main loop of your app. This message will\nbe handled by the overall `update` function, just like events from `Html`.\n",
        "type": "Platform.Router msg a -> msg -> Platform.Task x ()"
      },
      {
        "name": "sendToSelf",
        "comment": " Send the router a message for your effect manager. This message will\nbe routed to the `onSelfMsg` function, where you can update the state of your\neffect manager as necessary.\n\nAs an example, the effect manager for web sockets\n",
        "type": "Platform.Router a msg -> msg -> Platform.Task x ()"
      }
    ],
    "generated-with-elm-version": "0.17.0"
  },
  {
    "name": "Char",
    "comment": " Functions for working with characters. Character literals are enclosed in\n`'a'` pair of single quotes.\n\n# Classification\n@docs isUpper, isLower, isDigit, isOctDigit, isHexDigit\n\n# Conversion\n@docs toUpper, toLower, toLocaleUpper, toLocaleLower\n\n# Key Codes\n@docs KeyCode, toCode, fromCode\n\n",
    "aliases": [
      {
        "name": "KeyCode",
        "comment": " Keyboard keys can be represented as integers. These are called *key codes*.\nYou can use [`toCode`](#toCode) and [`fromCode`](#fromCode) to convert between\nkey codes and characters.\n",
        "args": [],
        "type": "Int"
      }
    ],
    "types": [],
    "values": [
      {
        "name": "fromCode",
        "comment": " Convert from key code. ",
        "type": "Char.KeyCode -> Char"
      },
      {
        "name": "isDigit",
        "comment": " True for ASCII digits `[0-9]`. ",
        "type": "Char -> Bool"
      },
      {
        "name": "isHexDigit",
        "comment": " True for ASCII hexadecimal digits `[0-9a-fA-F]`. ",
        "type": "Char -> Bool"
      },
      {
        "name": "isLower",
        "comment": " True for lower case ASCII letters. ",
        "type": "Char -> Bool"
      },
      {
        "name": "isOctDigit",
        "comment": " True for ASCII octal digits `[0-7]`. ",
        "type": "Char -> Bool"
      },
      {
        "name": "isUpper",
        "comment": " True for upper case ASCII letters. ",
        "type": "Char -> Bool"
      },
      {
        "name": "toCode",
        "comment": " Convert to key code.\n",
        "type": "Char -> Char.KeyCode"
      },
      {
        "name": "toLocaleLower",
        "comment": " Convert to lower case, according to any locale-specific case mappings. ",
        "type": "Char -> Char"
      },
      {
        "name": "toLocaleUpper",
        "comment": " Convert to upper case, according to any locale-specific case mappings. ",
        "type": "Char -> Char"
      },
      {
        "name": "toLower",
        "comment": " Convert to lower case. ",
        "type": "Char -> Char"
      },
      {
        "name": "toUpper",
        "comment": " Convert to upper case. ",
        "type": "Char -> Char"
      }
    ],
    "generated-with-elm-version": "0.17.0"
  },
  {
    "name": "Color",
    "comment": " Library for working with colors. Includes\n[RGB](https://en.wikipedia.org/wiki/RGB_color_model) and\n[HSL](http://en.wikipedia.org/wiki/HSL_and_HSV) creation, gradients, and\nbuilt-in names.\n\n# Colors\n@docs Color\n\n# Creation\n@docs rgb, rgba, hsl, hsla, greyscale, grayscale, complement\n\n# Gradients\n@docs Gradient, linear, radial\n\n# Extracting Colors\n@docs toRgb, toHsl\n\n# Built-in Colors\nThese colors come from the [Tango\npalette](http://tango.freedesktop.org/Tango_Icon_Theme_Guidelines)\nwhich provides aesthetically reasonable defaults for colors. Each color also\ncomes with a light and dark version.\n\n### Standard\n@docs red, orange, yellow, green, blue, purple, brown\n\n### Light\n@docs lightRed, lightOrange, lightYellow, lightGreen, lightBlue, lightPurple, lightBrown\n\n### Dark\n@docs darkRed, darkOrange, darkYellow, darkGreen, darkBlue, darkPurple, darkBrown\n\n### Eight Shades of Grey\nThese colors are a compatible series of shades of grey, fitting nicely\nwith the Tango palette.\n@docs white, lightGrey, grey, darkGrey, lightCharcoal, charcoal, darkCharcoal, black\n\nThese are identical to the *grey* versions. It seems the spelling is regional, but\nthat has never helped me remember which one I should be writing.\n@docs lightGray, gray, darkGray\n\n",
    "aliases": [],
    "types": [
      {
        "name": "Color",
        "comment": " Representation of colors.\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Gradient",
        "comment": " Abstract representation of a color gradient.\n",
        "args": [],
        "cases": []
      }
    ],
    "values": [
      {
        "name": "black",
        "comment": "",
        "type": "Color.Color"
      },
      {
        "name": "blue",
        "comment": "",
        "type": "Color.Color"
      },
      {
        "name": "brown",
        "comment": "",
        "type": "Color.Color"
      },
      {
        "name": "charcoal",
        "comment": "",
        "type": "Color.Color"
      },
      {
        "name": "complement",
        "comment": " Produce a &ldquo;complementary color&rdquo;. The two colors will\naccent each other. This is the same as rotating the hue by 180&deg;.\n",
        "type": "Color.Color -> Color.Color"
      },
      {
        "name": "darkBlue",
        "comment": "",
        "type": "Color.Color"
      },
      {
        "name": "darkBrown",
        "comment": "",
        "type": "Color.Color"
      },
      {
        "name": "darkCharcoal",
        "comment": "",
        "type": "Color.Color"
      },
      {
        "name": "darkGray",
        "comment": "",
        "type": "Color.Color"
      },
      {
        "name": "darkGreen",
        "comment": "",
        "type": "Color.Color"
      },
      {
        "name": "darkGrey",
        "comment": "",
        "type": "Color.Color"
      },
      {
        "name": "darkOrange",
        "comment": "",
        "type": "Color.Color"
      },
      {
        "name": "darkPurple",
        "comment": "",
        "type": "Color.Color"
      },
      {
        "name": "darkRed",
        "comment": "",
        "type": "Color.Color"
      },
      {
        "name": "darkYellow",
        "comment": "",
        "type": "Color.Color"
      },
      {
        "name": "gray",
        "comment": "",
        "type": "Color.Color"
      },
      {
        "name": "grayscale",
        "comment": " Produce a gray based on the input. 0 is white, 1 is black.\n",
        "type": "Float -> Color.Color"
      },
      {
        "name": "green",
        "comment": "",
        "type": "Color.Color"
      },
      {
        "name": "grey",
        "comment": "",
        "type": "Color.Color"
      },
      {
        "name": "greyscale",
        "comment": " Produce a gray based on the input. 0 is white, 1 is black.\n",
        "type": "Float -> Color.Color"
      },
      {
        "name": "hsl",
        "comment": " Create [HSL colors](http://en.wikipedia.org/wiki/HSL_and_HSV). This gives\nyou access to colors more like a color wheel, where all hues are arranged in a\ncircle that you specify with standard Elm angles (radians).\n\n    red   = hsl (degrees   0) 1 0.5\n    green = hsl (degrees 120) 1 0.5\n    blue  = hsl (degrees 240) 1 0.5\n\n    pastelRed = hsl (degrees 0) 0.7 0.7\n\nTo cycle through all colors, just cycle through degrees. The saturation level\nis how vibrant the color is, like a dial between grey and bright colors. The\nlightness level is a dial between white and black.\n",
        "type": "Float -> Float -> Float -> Color.Color"
      },
      {
        "name": "hsla",
        "comment": " Create [HSL colors](http://en.wikipedia.org/wiki/HSL_and_HSV)\nwith an alpha component for transparency.\n",
        "type": "Float -> Float -> Float -> Float -> Color.Color"
      },
      {
        "name": "lightBlue",
        "comment": "",
        "type": "Color.Color"
      },
      {
        "name": "lightBrown",
        "comment": "",
        "type": "Color.Color"
      },
      {
        "name": "lightCharcoal",
        "comment": "",
        "type": "Color.Color"
      },
      {
        "name": "lightGray",
        "comment": "",
        "type": "Color.Color"
      },
      {
        "name": "lightGreen",
        "comment": "",
        "type": "Color.Color"
      },
      {
        "name": "lightGrey",
        "comment": "",
        "type": "Color.Color"
      },
      {
        "name": "lightOrange",
        "comment": "",
        "type": "Color.Color"
      },
      {
        "name": "lightPurple",
        "comment": "",
        "type": "Color.Color"
      },
      {
        "name": "lightRed",
        "comment": "",
        "type": "Color.Color"
      },
      {
        "name": "lightYellow",
        "comment": "",
        "type": "Color.Color"
      },
      {
        "name": "linear",
        "comment": " Create a linear gradient. Takes a start and end point and then a series of\n&ldquo;color stops&rdquo; that indicate how to interpolate between the start and\nend points. See [this example](http://elm-lang.org/examples/linear-gradient) for a\nmore visual explanation.\n",
        "type": "( Float, Float ) -> ( Float, Float ) -> List ( Float, Color.Color ) -> Color.Gradient"
      },
      {
        "name": "orange",
        "comment": "",
        "type": "Color.Color"
      },
      {
        "name": "purple",
        "comment": "",
        "type": "Color.Color"
      },
      {
        "name": "radial",
        "comment": " Create a radial gradient. First takes a start point and inner radius.  Then\ntakes an end point and outer radius. It then takes a series of &ldquo;color\nstops&rdquo; that indicate how to interpolate between the inner and outer\ncircles. See [this example](http://elm-lang.org/examples/radial-gradient) for a\nmore visual explanation.\n",
        "type": "( Float, Float ) -> Float -> ( Float, Float ) -> Float -> List ( Float, Color.Color ) -> Color.Gradient"
      },
      {
        "name": "red",
        "comment": "",
        "type": "Color.Color"
      },
      {
        "name": "rgb",
        "comment": " Create RGB colors from numbers between 0 and 255 inclusive. ",
        "type": "Int -> Int -> Int -> Color.Color"
      },
      {
        "name": "rgba",
        "comment": " Create RGB colors with an alpha component for transparency.\nThe alpha component is specified with numbers between 0 and 1. ",
        "type": "Int -> Int -> Int -> Float -> Color.Color"
      },
      {
        "name": "toHsl",
        "comment": " Extract the components of a color in the HSL format.\n",
        "type": "Color.Color -> { hue : Float , saturation : Float , lightness : Float , alpha : Float }"
      },
      {
        "name": "toRgb",
        "comment": " Extract the components of a color in the RGB format.\n",
        "type": "Color.Color -> { red : Int, green : Int, blue : Int, alpha : Float }"
      },
      {
        "name": "white",
        "comment": "",
        "type": "Color.Color"
      },
      {
        "name": "yellow",
        "comment": "",
        "type": "Color.Color"
      }
    ],
    "generated-with-elm-version": "0.17.0"
  },
  {
    "name": "Platform.Cmd",
    "comment": "\n\n# Effects\n\nElm has **managed effects**, meaning that things like HTTP requests or writing\nto disk are all treated as *data* in Elm. When this data is given to the Elm\nruntime system, it can do some “query optimization” before actually performing\nthe effect. Perhaps unexpectedly, this managed effects idea is the heart of why\nElm is so nice for testing, reuse, reproducibility, etc.\n\nThere are two kinds of managed effects you will use in your programs: commands\nand subscriptions.\n\n@docs Cmd, map, batch, none, (!)\n\n",
    "aliases": [],
    "types": [
      {
        "name": "Cmd",
        "comment": " A command is a way of telling Elm, “Hey, I want you to do this thing!”\nSo if you want to send an HTTP request, you would need to command Elm to do it.\nOr if you wanted to ask for geolocation, you would need to command Elm to go\nget it.\n\nEvery `Cmd` specifies (1) which effects you need access to and (2) the type of\nmessages that will come back into your application.\n\n**Note:** Do not worry if this seems confusing at first! As with every Elm user\never, commands will make more sense as you work through [the Elm Architecture\nTutorial](http://guide.elm-lang.org/architecture/index.html) and see how they\nfit into a real application!\n",
        "args": [
          "msg"
        ],
        "cases": []
      }
    ],
    "values": [
      {
        "name": "!",
        "comment": "",
        "type": "model -> List (Platform.Cmd.Cmd msg) -> ( model, Platform.Cmd.Cmd msg )"
      },
      {
        "name": "batch",
        "comment": "",
        "type": "List (Platform.Cmd.Cmd msg) -> Platform.Cmd.Cmd msg"
      },
      {
        "name": "map",
        "comment": "",
        "type": "(a -> msg) -> Platform.Cmd.Cmd a -> Platform.Cmd.Cmd msg"
      },
      {
        "name": "none",
        "comment": "",
        "type": "Platform.Cmd.Cmd msg"
      }
    ],
    "generated-with-elm-version": "0.17.0"
  },
  {
    "name": "Platform.Sub",
    "comment": "\n\n@docs Sub, map, batch, none\n",
    "aliases": [],
    "types": [
      {
        "name": "Sub",
        "comment": " A subscription is a way of telling Elm, “Hey, let me know if anything\ninteresting happens over there!” So if you want listen for messages on a web\nsocket, you would tell Elm to create a subscription. If you want to get clock\nticks, you would tell Elm to subscribe to that. The cool thing here is that\nthis means *Elm* manages all the details of subscriptions instead of *you*.\nSo if a web socket goes down, *you* do not need to manually reconnect with an\nexponential backoff strategy, *Elm* does this all for you behind the scenes!\n\nEvery `Sub` specifies (1) which effects you need access to and (2) the type of\nmessages that will come back into your application.\n\n**Note:** Do not worry if this seems confusing at first! As with every Elm user\never, subscriptions will make more sense as you work through [the Elm Architecture\nTutorial](http://guide.elm-lang.org/architecture/index.html) and see how they fit\ninto a real application!\n",
        "args": [
          "msg"
        ],
        "cases": []
      }
    ],
    "values": [
      {
        "name": "batch",
        "comment": "",
        "type": "List (Platform.Sub.Sub msg) -> Platform.Sub.Sub msg"
      },
      {
        "name": "map",
        "comment": "",
        "type": "(a -> msg) -> Platform.Sub.Sub a -> Platform.Sub.Sub msg"
      },
      {
        "name": "none",
        "comment": "",
        "type": "Platform.Sub.Sub msg"
      }
    ],
    "generated-with-elm-version": "0.17.0"
  },
  {
    "name": "Maybe",
    "comment": " This library fills a bunch of important niches in Elm. A `Maybe` can help\nyou with optional arguments, error handling, and records with optional fields.\n\n# Definition\n@docs Maybe\n\n# Common Helpers\n@docs withDefault, oneOf, map, map2, map3, map4, map5\n\n# Chaining Maybes\n@docs andThen\n\n",
    "aliases": [],
    "types": [
      {
        "name": "Maybe",
        "comment": " Represent values that may or may not exist. It can be useful if you have a\nrecord field that is only filled in sometimes. Or if a function takes a value\nsometimes, but does not absolutely need it.\n\n    -- A person, but maybe we do not know their age.\n    type alias Person =\n        { name : String\n        , age : Maybe Int\n        }\n\n    tom = { name = \"Tom\", age = Just 42 }\n    sue = { name = \"Sue\", age = Nothing }\n",
        "args": [
          "a"
        ],
        "cases": [
          [
            "Just",
            [
              "a"
            ]
          ],
          [
            "Nothing",
            []
          ]
        ]
      }
    ],
    "values": [
      {
        "name": "andThen",
        "comment": " Chain together many computations that may fail. It is helpful to see its\ndefinition:\n\n    andThen : Maybe a -> (a -> Maybe b) -> Maybe b\n    andThen maybe callback =\n        case maybe of\n            Just value ->\n                callback value\n\n            Nothing ->\n                Nothing\n\nThis means we only continue with the callback if things are going well. For\nexample, say you need to use (`head : List Int -> Maybe Int`) to get the\nfirst month from a `List` and then make sure it is between 1 and 12:\n\n    toValidMonth : Int -> Maybe Int\n    toValidMonth month =\n        if month >= 1 && month <= 12 then\n            Just month\n        else\n            Nothing\n\n    getFirstMonth : List Int -> Maybe Int\n    getFirstMonth months =\n        head months `andThen` toValidMonth\n\nIf `head` fails and results in `Nothing` (because the `List` was `empty`),\nthis entire chain of operations will short-circuit and result in `Nothing`.\nIf `toValidMonth` results in `Nothing`, again the chain of computations\nwill result in `Nothing`.\n",
        "type": "Maybe.Maybe a -> (a -> Maybe.Maybe b) -> Maybe.Maybe b"
      },
      {
        "name": "map",
        "comment": " Transform a `Maybe` value with a given function:\n\n    map sqrt (Just 9) == Just 3\n    map sqrt Nothing == Nothing\n",
        "type": "(a -> b) -> Maybe.Maybe a -> Maybe.Maybe b"
      },
      {
        "name": "map2",
        "comment": " Apply a function if all the arguments are `Just` a value.\n\n    map2 (+) (Just 3) (Just 4) == Just 7\n    map2 (+) (Just 3) Nothing == Nothing\n    map2 (+) Nothing (Just 4) == Nothing\n",
        "type": "(a -> b -> value) -> Maybe.Maybe a -> Maybe.Maybe b -> Maybe.Maybe value"
      },
      {
        "name": "map3",
        "comment": "",
        "type": "(a -> b -> c -> value) -> Maybe.Maybe a -> Maybe.Maybe b -> Maybe.Maybe c -> Maybe.Maybe value"
      },
      {
        "name": "map4",
        "comment": "",
        "type": "(a -> b -> c -> d -> value) -> Maybe.Maybe a -> Maybe.Maybe b -> Maybe.Maybe c -> Maybe.Maybe d -> Maybe.Maybe value"
      },
      {
        "name": "map5",
        "comment": "",
        "type": "(a -> b -> c -> d -> e -> value) -> Maybe.Maybe a -> Maybe.Maybe b -> Maybe.Maybe c -> Maybe.Maybe d -> Maybe.Maybe e -> Maybe.Maybe value"
      },
      {
        "name": "oneOf",
        "comment": " Pick the first `Maybe` that actually has a value. Useful when you want to\ntry a couple different things, but there is no default value.\n\n    oneOf [ Nothing, Just 42, Just 71 ] == Just 42\n    oneOf [ Nothing, Nothing, Just 71 ] == Just 71\n    oneOf [ Nothing, Nothing, Nothing ] == Nothing\n",
        "type": "List (Maybe.Maybe a) -> Maybe.Maybe a"
      },
      {
        "name": "withDefault",
        "comment": " Provide a default value, turning an optional value into a normal\nvalue.  This comes in handy when paired with functions like\n[`Dict.get`](Dict#get) which gives back a `Maybe`.\n\n    withDefault 100 (Just 42)   -- 42\n    withDefault 100 Nothing     -- 100\n\n    withDefault \"unknown\" (Dict.get \"Tom\" Dict.empty)   -- \"unknown\"\n\n",
        "type": "a -> Maybe.Maybe a -> a"
      }
    ],
    "generated-with-elm-version": "0.17.0"
  },
  {
    "name": "Debug",
    "comment": " This library is for investigating bugs or performance problems. It should\n*not* be used in production code.\n\n# Debugging\n@docs log, crash\n",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "crash",
        "comment": " Crash the program with an error message. This is an uncatchable error,\nintended for code that is soon-to-be-implemented. For example, if you are\nworking with a large ADT and have partially completed a case expression, it may\nmake sense to do this:\n\n    type Entity = Ship | Fish | Captain | Seagull\n\n    drawEntity entity =\n      case entity of\n        Ship ->\n          ...\n\n        Fish ->\n          ...\n\n        _ ->\n          Debug.crash \"TODO\"\n\nThe Elm compiler recognizes each `Debug.crash` and when you run into it at\nruntime, the error will point to the corresponding module name and line number.\nFor `case` expressions that ends with a wildcard pattern and a crash, it will\nalso show the value that snuck through. In our example, that'd be `Captain` or\n`Seagull`.\n\n**Use this if** you want to do some testing while you are partway through\nwriting a function.\n\n**Do not use this if** you want to do some typical try-catch exception handling.\nUse the [`Maybe`](Maybe) or [`Result`](Result) libraries instead.\n",
        "type": "String -> a"
      },
      {
        "name": "log",
        "comment": " Log a tagged value on the developer console, and then return the value.\n\n    1 + log \"number\" 1        -- equals 2, logs \"number: 1\"\n    length (log \"start\" [])   -- equals 0, logs \"start: []\"\n\nNotice that `log` is not a pure function! It should *only* be used for\ninvestigating bugs or performance problems.\n",
        "type": "String -> a -> a"
      }
    ],
    "generated-with-elm-version": "0.17.0"
  },
  {
    "name": "Bitwise",
    "comment": " Library for [bitwise operations](http://en.wikipedia.org/wiki/Bitwise_operation).\n\n# Basic Operations\n\n@docs and, or, xor, complement\n\n# Bit Shifts\n\n@docs shiftLeft, shiftRight, shiftRightLogical\n",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "and",
        "comment": " Bitwise AND\n",
        "type": "Int -> Int -> Int"
      },
      {
        "name": "complement",
        "comment": " Flip each bit individually, often called bitwise NOT\n",
        "type": "Int -> Int"
      },
      {
        "name": "or",
        "comment": " Bitwise OR\n",
        "type": "Int -> Int -> Int"
      },
      {
        "name": "shiftLeft",
        "comment": " Shift bits to the left by a given offset, filling new bits with zeros.\nThis can be used to multiply numbers by powers of two.\n\n    8 `shiftLeft` 1 == 16\n    8 `shiftLeft` 2 == 32\n",
        "type": "Int -> Int -> Int"
      },
      {
        "name": "shiftRight",
        "comment": " Shift bits to the right by a given offset, filling new bits with\nwhatever is the topmost bit. This can be used to divide numbers by powers of two.\n\n     32 `shiftRight` 1 == 16\n     32 `shiftRight` 2 == 8\n    -32 `shiftRight` 1 == -16\n\nThis is called an [arithmetic right\nshift](http://en.wikipedia.org/wiki/Bitwise_operation#Arithmetic_shift),\noften written (>>), and sometimes called a sign-propagating\nright shift because it fills empty spots with copies of the highest bit.\n",
        "type": "Int -> Int -> Int"
      },
      {
        "name": "shiftRightLogical",
        "comment": " Shift bits to the right by a given offset, filling new bits with\nzeros.\n\n     32 `shiftRightLogical` 1 == 16\n     32 `shiftRightLogical` 2 == 8\n    -32 `shiftRightLogical` 1 == 2147483632\n\nThis is called an [logical right\nshift](http://en.wikipedia.org/wiki/Bitwise_operation#Logical_shift), often written (>>>),\nand sometimes called a zero-fill right shift because it fills empty spots\nwith zeros.\n",
        "type": "Int -> Int -> Int"
      },
      {
        "name": "xor",
        "comment": " Bitwise XOR\n",
        "type": "Int -> Int -> Int"
      }
    ],
    "generated-with-elm-version": "0.17.0"
  },
  {
    "name": "Basics",
    "comment": " Tons of useful functions that get imported by default.\n\n# Equality\n@docs (==), (/=)\n\n# Comparison\n\nThese functions only work on `comparable` types. This includes numbers,\ncharacters, strings, lists of comparable things, and tuples of comparable\nthings. Note that tuples with 7 or more elements are not comparable; why\nare your tuples so big?\n\n@docs (<), (>), (<=), (>=), max, min, Order, compare\n\n# Booleans\n@docs not, (&&), (||), xor\n\n# Mathematics\n@docs (+), (-), (*), (/), (^), (//), rem, (%), negate, abs, sqrt, clamp, logBase, e\n\n# Trigonometry\n@docs pi, cos, sin, tan, acos, asin, atan, atan2\n\n# Number Conversions\n@docs round, floor, ceiling, truncate, toFloat\n\n# Angle Conversions\nAll angle conversions result in &ldquo;standard Elm angles&rdquo;\nwhich happen to be radians.\n\n@docs degrees, radians, turns\n\n# Polar Coordinates\n@docs toPolar, fromPolar\n\n# Floating Point Checks\n@docs isNaN, isInfinite\n\n# Strings and Lists\n@docs toString, (++)\n\n# Tuples\n@docs fst, snd\n\n# Higher-Order Helpers\n@docs identity, always, (<|), (|>), (<<), (>>), flip, curry, uncurry, Never\n\n",
    "aliases": [],
    "types": [
      {
        "name": "Never",
        "comment": " A type that is \"uninhabited\". There are no values of type `Never`, and its\nprimary use is demanding that certain tasks cannot possibly fail.\n\nFor example, a task with type `(Task Never Int)` must *always* succeed with an\ninteger. For the task to fail, someone would need to say `(Task.fail ???)` but\nsince there is no value with type `Never` they could not fill in the question\nmarks!\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Order",
        "comment": " Represents the relative ordering of two things.\nThe relations are less than, equal to, and greater than.\n",
        "args": [],
        "cases": [
          [
            "LT",
            []
          ],
          [
            "EQ",
            []
          ],
          [
            "GT",
            []
          ]
        ]
      }
    ],
    "values": [
      {
        "name": "%",
        "comment": " Perform [modular arithmetic](http://en.wikipedia.org/wiki/Modular_arithmetic).\n\n     7 % 2 == 1\n    -1 % 4 == 3\n",
        "type": "Int -> Int -> Int",
        "associativity": "left",
        "precedence": 7
      },
      {
        "name": "&&",
        "comment": " The logical AND operator. `True` if both inputs are `True`.\n\n**Note:** When used in the infix position, like `(left && right)`, the operator\nshort-circuits. This means if `left` is `False` we do not bother evaluating `right`\nand just return `False` overall.\n",
        "type": "Bool -> Bool -> Bool",
        "associativity": "right",
        "precedence": 3
      },
      {
        "name": "*",
        "comment": "",
        "type": "number -> number -> number",
        "associativity": "left",
        "precedence": 7
      },
      {
        "name": "+",
        "comment": "",
        "type": "number -> number -> number",
        "associativity": "left",
        "precedence": 6
      },
      {
        "name": "++",
        "comment": " Put two appendable things together. This includes strings, lists, and text.\n\n    \"hello\" ++ \"world\" == \"helloworld\"\n    [1,1,2] ++ [3,5,8] == [1,1,2,3,5,8]\n",
        "type": "appendable -> appendable -> appendable",
        "associativity": "right",
        "precedence": 5
      },
      {
        "name": "-",
        "comment": "",
        "type": "number -> number -> number",
        "associativity": "left",
        "precedence": 6
      },
      {
        "name": "/",
        "comment": " Floating point division. ",
        "type": "Float -> Float -> Float",
        "associativity": "left",
        "precedence": 7
      },
      {
        "name": "//",
        "comment": " Integer division. The remainder is discarded. ",
        "type": "Int -> Int -> Int",
        "associativity": "left",
        "precedence": 7
      },
      {
        "name": "/=",
        "comment": "",
        "type": "a -> a -> Bool",
        "associativity": "non",
        "precedence": 4
      },
      {
        "name": "<",
        "comment": "",
        "type": "comparable -> comparable -> Bool",
        "associativity": "non",
        "precedence": 4
      },
      {
        "name": "<<",
        "comment": " Function composition, passing results along in the suggested direction. For\nexample, the following code checks if the square root of a number is odd:\n\n    not << isEven << sqrt\n\nYou can think of this operator as equivalent to the following:\n\n    (g << f)  ==  (\\x -> g (f x))\n\nSo our example expands out to something like this:\n\n    \\n -> not (isEven (sqrt n))\n",
        "type": "(b -> c) -> (a -> b) -> a -> c",
        "associativity": "right",
        "precedence": 9
      },
      {
        "name": "<=",
        "comment": "",
        "type": "comparable -> comparable -> Bool",
        "associativity": "non",
        "precedence": 4
      },
      {
        "name": "<|",
        "comment": " Backward function application `f <| x == f x`. This function is useful for\navoiding parentheses. Consider the following code to create a text element:\n\n    leftAligned (monospace (fromString \"code\"))\n\nThis can also be written as:\n\n    leftAligned <| monospace <| fromString \"code\"\n",
        "type": "(a -> b) -> a -> b",
        "associativity": "right",
        "precedence": 0
      },
      {
        "name": "==",
        "comment": "",
        "type": "a -> a -> Bool",
        "associativity": "non",
        "precedence": 4
      },
      {
        "name": ">",
        "comment": "",
        "type": "comparable -> comparable -> Bool",
        "associativity": "non",
        "precedence": 4
      },
      {
        "name": ">=",
        "comment": "",
        "type": "comparable -> comparable -> Bool",
        "associativity": "non",
        "precedence": 4
      },
      {
        "name": ">>",
        "comment": " Function composition, passing results along in the suggested direction. For\nexample, the following code checks if the square root of a number is odd:\n\n    sqrt >> isEven >> not\n\nThis direction of function composition seems less pleasant than `(<<)` which\nreads nicely in expressions like: `filter (not << isRegistered) students`\n",
        "type": "(a -> b) -> (b -> c) -> a -> c",
        "associativity": "left",
        "precedence": 9
      },
      {
        "name": "^",
        "comment": " Exponentiation\n\n    3^2 == 9\n",
        "type": "number -> number -> number",
        "associativity": "right",
        "precedence": 8
      },
      {
        "name": "abs",
        "comment": " Take the absolute value of a number. ",
        "type": "number -> number"
      },
      {
        "name": "acos",
        "comment": "",
        "type": "Float -> Float"
      },
      {
        "name": "always",
        "comment": " Create a [constant function](http://en.wikipedia.org/wiki/Constant_function),\na function that *always* returns the same value regardless of what input you give.\nIt is defined as:\n\n    always a b = a\n\nIt totally ignores the second argument, so `always 42` is a function that always\nreturns 42. When you are dealing with higher-order functions, this comes in\nhandy more often than you might expect. For example, creating a zeroed out list\nof length ten would be:\n\n    map (always 0) [0..9]\n",
        "type": "a -> b -> a"
      },
      {
        "name": "asin",
        "comment": "",
        "type": "Float -> Float"
      },
      {
        "name": "atan",
        "comment": " You probably do not want to use this. It takes `(y/x)` as the\nargument, so there is no way to know whether the negative signs comes from\nthe `y` or `x`. Thus, the resulting angle is always between &pi;/2 and -&pi;/2\n(in quadrants I and IV). You probably want to use `atan2` instead.\n",
        "type": "Float -> Float"
      },
      {
        "name": "atan2",
        "comment": " This helps you find the angle of a Cartesian coordinate.\nYou will almost certainly want to use this instead of `atan`.\nSo `atan2 y x` computes *atan(y/x)* but also keeps track of which\nquadrant the angle should really be in. The result will be between\n&pi; and -&pi;, giving you the full range of angles.\n",
        "type": "Float -> Float -> Float"
      },
      {
        "name": "ceiling",
        "comment": " Ceiling function, rounding up. ",
        "type": "Float -> Int"
      },
      {
        "name": "clamp",
        "comment": " Clamps a number within a given range. With the expression\n`clamp 100 200 x` the results are as follows:\n\n    100     if x < 100\n     x      if 100 <= x < 200\n    200     if 200 <= x\n",
        "type": "number -> number -> number -> number"
      },
      {
        "name": "compare",
        "comment": " Compare any two comparable values. Comparable values include `String`, `Char`,\n`Int`, `Float`, `Time`, or a list or tuple containing comparable values.\nThese are also the only values that work as `Dict` keys or `Set` members.\n",
        "type": "comparable -> comparable -> Basics.Order"
      },
      {
        "name": "cos",
        "comment": "",
        "type": "Float -> Float"
      },
      {
        "name": "curry",
        "comment": " Change how arguments are passed to a function.\nThis splits paired arguments into two separate arguments.\n",
        "type": "(( a, b ) -> c) -> a -> b -> c"
      },
      {
        "name": "degrees",
        "comment": " Convert degrees to standard Elm angles (radians). ",
        "type": "Float -> Float"
      },
      {
        "name": "e",
        "comment": " An approximation of e. ",
        "type": "Float"
      },
      {
        "name": "flip",
        "comment": " Flip the order of the first two arguments to a function. ",
        "type": "(a -> b -> c) -> b -> a -> c"
      },
      {
        "name": "floor",
        "comment": " Floor function, rounding down. ",
        "type": "Float -> Int"
      },
      {
        "name": "fromPolar",
        "comment": " Convert polar coordinates (r,&theta;) to Cartesian coordinates (x,y). ",
        "type": "( Float, Float ) -> ( Float, Float )"
      },
      {
        "name": "fst",
        "comment": " Given a 2-tuple, returns the first value. ",
        "type": "( a, b ) -> a"
      },
      {
        "name": "identity",
        "comment": " Given a value, returns exactly the same value. This is called\n[the identity function](http://en.wikipedia.org/wiki/Identity_function).\n",
        "type": "a -> a"
      },
      {
        "name": "isInfinite",
        "comment": " Determine whether a float is positive or negative infinity.\n\n    isInfinite (0/0)     == False\n    isInfinite (sqrt -1) == False\n    isInfinite (1/0)     == True\n    isInfinite 1         == False\n\nNotice that NaN is not infinite! For float `n` to be finite implies that\n`not (isInfinite n || isNaN n)` evaluates to `True`.\n",
        "type": "Float -> Bool"
      },
      {
        "name": "isNaN",
        "comment": " Determine whether a float is an undefined or unrepresentable number.\nNaN stands for *not a number* and it is [a standardized part of floating point\nnumbers](http://en.wikipedia.org/wiki/NaN).\n\n    isNaN (0/0)     == True\n    isNaN (sqrt -1) == True\n    isNaN (1/0)     == False  -- infinity is a number\n    isNaN 1         == False\n",
        "type": "Float -> Bool"
      },
      {
        "name": "logBase",
        "comment": " Calculate the logarithm of a number with a given base.\n\n    logBase 10 100 == 2\n    logBase 2 256 == 8\n",
        "type": "Float -> Float -> Float"
      },
      {
        "name": "max",
        "comment": " Find the larger of two comparables. ",
        "type": "comparable -> comparable -> comparable"
      },
      {
        "name": "min",
        "comment": " Find the smaller of two comparables. ",
        "type": "comparable -> comparable -> comparable"
      },
      {
        "name": "negate",
        "comment": " Negate a number.\n\n    negate 42 == -42\n    negate -42 == 42\n    negate 0 == 0\n",
        "type": "number -> number"
      },
      {
        "name": "not",
        "comment": " Negate a boolean value.\n\n    not True == False\n    not False == True\n",
        "type": "Bool -> Bool"
      },
      {
        "name": "pi",
        "comment": " An approximation of pi. ",
        "type": "Float"
      },
      {
        "name": "radians",
        "comment": " Convert radians to standard Elm angles (radians). ",
        "type": "Float -> Float"
      },
      {
        "name": "rem",
        "comment": " Find the remainder after dividing one number by another.\n\n     7 `rem` 2 == 1\n    -1 `rem` 4 == -1\n",
        "type": "Int -> Int -> Int",
        "associativity": "left",
        "precedence": 7
      },
      {
        "name": "round",
        "comment": " Round a number to the nearest integer. ",
        "type": "Float -> Int"
      },
      {
        "name": "sin",
        "comment": "",
        "type": "Float -> Float"
      },
      {
        "name": "snd",
        "comment": " Given a 2-tuple, returns the second value. ",
        "type": "( a, b ) -> b"
      },
      {
        "name": "sqrt",
        "comment": " Take the square root of a number. ",
        "type": "Float -> Float"
      },
      {
        "name": "tan",
        "comment": "",
        "type": "Float -> Float"
      },
      {
        "name": "toFloat",
        "comment": " Convert an integer into a float. ",
        "type": "Int -> Float"
      },
      {
        "name": "toPolar",
        "comment": " Convert Cartesian coordinates (x,y) to polar coordinates (r,&theta;). ",
        "type": "( Float, Float ) -> ( Float, Float )"
      },
      {
        "name": "toString",
        "comment": " Turn any kind of value into a string. When you view the resulting string\nwith `Text.fromString` it should look just like the value it came from.\n\n    toString 42 == \"42\"\n    toString [1,2] == \"[1,2]\"\n    toString \"he said, \\\"hi\\\"\" == \"\\\"he said, \\\\\\\"hi\\\\\\\"\\\"\"\n",
        "type": "a -> String"
      },
      {
        "name": "truncate",
        "comment": " Truncate a number, rounding towards zero. ",
        "type": "Float -> Int"
      },
      {
        "name": "turns",
        "comment": " Convert turns to standard Elm angles (radians).\nOne turn is equal to 360&deg;.\n",
        "type": "Float -> Float"
      },
      {
        "name": "uncurry",
        "comment": " Change how arguments are passed to a function.\nThis combines two arguments into a single pair.\n",
        "type": "(a -> b -> c) -> ( a, b ) -> c"
      },
      {
        "name": "xor",
        "comment": " The exclusive-or operator. `True` if exactly one input is `True`. ",
        "type": "Bool -> Bool -> Bool"
      },
      {
        "name": "|>",
        "comment": " Forward function application `x |> f == f x`. This function is useful\nfor avoiding parentheses and writing code in a more natural way.\nConsider the following code to create a pentagon:\n\n    scale 2 (move (10,10) (filled blue (ngon 5 30)))\n\nThis can also be written as:\n\n    ngon 5 30\n      |> filled blue\n      |> move (10,10)\n      |> scale 2\n",
        "type": "a -> (a -> b) -> b",
        "associativity": "left",
        "precedence": 0
      },
      {
        "name": "||",
        "comment": " The logical OR operator. `True` if one or both inputs are `True`.\n\n**Note:** When used in the infix position, like `(left || right)`, the operator\nshort-circuits. This means if `left` is `True` we do not bother evaluating `right`\nand just return `True` overall.\n",
        "type": "Bool -> Bool -> Bool",
        "associativity": "right",
        "precedence": 2
      }
    ],
    "generated-with-elm-version": "0.17.0"
  }
]